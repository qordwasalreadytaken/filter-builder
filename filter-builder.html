
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoD FilterBuilder - Visual Filter Builder</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: #2a2a2a;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        h1 {
            margin: 0 0 10px 0;
            color: #fff;
        }

        .subtitle {
            color: #999;
            font-size: 14px;
        }

        .layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
        }

        .editor-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .section {
            background: #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .section-header {
            padding: 15px 20px;
            background: #333;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            border-bottom: 1px solid #444;
        }

        .section-header:hover {
            background: #3a3a3a;
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
        }

        .section-toggle {
            font-size: 20px;
            color: #999;
            transition: transform 0.2s;
        }

        .section.expanded .section-toggle {
            transform: rotate(90deg);
        }

        .section-content {
            display: none;
            padding: 15px 20px;
        }

        .section.expanded .section-content {
            display: block;
        }

        .preset-controls {
            margin-bottom: 15px;
            padding: 10px;
            background: #252525;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .preset-controls label {
            font-size: 13px;
            color: #aaa;
            margin: 0;
        }

        .preset-select {
            padding: 8px;
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
            flex: 1;
            min-width: 200px;
        }

        .group-settings-btn {
            padding: 8px 16px;
            background: #4a4a4a;
            border: 1px solid #666;
            border-radius: 4px;
            color: #4fc3f7;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .group-settings-btn:hover {
            background: #555;
            border-color: #4fc3f7;
            box-shadow: 0 0 8px rgba(79, 195, 247, 0.3);
        }

        .item-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .item-row {
            padding: 10px;
            background: #252525;
            border-radius: 4px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .custom-color-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .custom-label {
            font-size: 11px;
            color: #999;
        }

        .colors-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .item-row:hover {
            background: #2a2a2a;
        }

        .item-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .item-name {
            font-size: 14px;
            color: #ddd;
        }

        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;
            position: relative;
        }

        .color-clear-btn {
            width: 18px;
            height: 18px;
            padding: 0;
            background: #444;
            border: 1px solid #555;
            border-radius: 3px;
            color: #aaa;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .color-clear-btn:hover {
            background: #555;
            color: #fff;
        }

        .color-label {
            font-size: 11px;
            color: #999;
            min-width: 50px;
        }

        .color-input {
            width: 50px;
            height: 28px;
            border: 1px solid #444;
            border-radius: 3px;
            cursor: pointer;
            background: #333;
        }

        .color-select {
            width: 100px;
            height: 28px;
            padding: 4px;
            border: 1px solid #444;
            border-radius: 3px;
            background: #333;
            color: #e0e0e0;
            font-size: 11px;
            cursor: pointer;
        }

        .output-panel {
            position: sticky;
            top: 20px;
            height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
        }

        .output-section {
            background: #2a2a2a;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        .output-header {
            padding: 15px 20px;
            background: #333;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .output-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
        }

        .output-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            background: #4a4a4a;
            border: 1px solid #555;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #555;
        }

        .btn-primary {
            background: #0066cc;
            border-color: #0066cc;
        }

        .btn-primary:hover {
            background: #0052a3;
        }

        .output-textarea {
            flex: 1;
            padding: 15px;
            background: #1a1a1a;
            border: none;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: none;
            line-height: 1.5;
        }

        .output-textarea:focus {
            outline: none;
        }

        .output-textarea.highlight-active {
            background: linear-gradient(to right, #2a4a2a 0%, #1a1a1a 100%);
            transition: background 0.3s ease;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 9999;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-container {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            animation: modalFadeIn 0.2s ease-out;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-header {
            padding: 20px;
            background: #333;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            margin: 0;
        }

        .modal-close {
            background: transparent;
            border: none;
            color: #999;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            line-height: 1;
        }

        .modal-close:hover {
            background: #444;
            color: #fff;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-section {
            margin-bottom: 25px;
        }

        .modal-section:last-child {
            margin-bottom: 0;
        }

        .modal-section-title {
            font-size: 14px;
            font-weight: 600;
            color: #ccc;
            margin: 0 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #444;
        }

        .modal-control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .modal-checkbox-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        .modal-checkbox-label {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: #252525;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .modal-checkbox-label:hover {
            background: #2d2d2d;
        }

        .modal-checkbox-label input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }

        .modal-checkbox-label input[type="checkbox"]:checked + span {
            color: #0066cc;
            font-weight: bold;
        }

        .modal-button-group {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .modal-btn {
            padding: 6px 12px;
            background: #444;
            border: 1px solid #555;
            border-radius: 4px;
            color: #ddd;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .modal-btn:hover {
            background: #555;
        }

        .modal-color-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #252525;
            border-radius: 4px;
        }

        .modal-color-label {
            font-size: 12px;
            color: #999;
            min-width: 80px;
        }

        .modal-color-input {
            width: 60px;
            height: 30px;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            background: #333;
        }

        .modal-select {
            flex: 1;
            padding: 6px 8px;
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 12px;
            cursor: pointer;
        }

        .modal-clear-btn {
            padding: 6px 12px;
            background: #444;
            border: 1px solid #555;
            border-radius: 4px;
            color: #aaa;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .modal-clear-btn:hover {
            background: #555;
            color: #fff;
        }

        .settings-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            background: #444;
            border: 1px solid #555;
            border-radius: 4px;
            color: #aaa;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .settings-btn:hover {
            background: #555;
            color: #fff;
            transform: rotate(30deg);
        }

        .settings-btn.modified {
            background: #1a4d7a;
            border-color: #4fc3f7;
            color: #4fc3f7;
        }

        .settings-btn.modified:hover {
            background: #2563a3;
            border-color: #81d4fa;
            color: #81d4fa;
            transform: rotate(30deg);
        }

        .socket-checkbox-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .socket-checkbox-label {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            background: #252525;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .socket-checkbox-label:hover {
            background: #2d2d2d;
        }

        .socket-checkbox-label input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }

        .item-count {
            font-size: 12px;
            color: #777;
            margin-left: 5px;
        }

        /* Hide default file input */
        input[type="file"] {
            display: none;
        }

        .filter-info {
            padding: 10px 20px;
            background: #252525;
            border-top: 1px solid #444;
            font-size: 12px;
            color: #999;
        }

        .global-settings {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .global-settings h3 {
            margin: 0 0 15px 0;
            color: #fff;
            font-size: 16px;
        }

        .filter-levels-config {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }

        .filter-levels-config.active {
            display: block;
        }

        .level-names-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .level-name-input {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .level-name-input label {
            font-size: 11px;
            color: #999;
        }

        .level-name-input input {
            padding: 6px 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 3px;
            color: #e0e0e0;
            font-size: 12px;
        }

        .levels-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 10px;
        }

        .levels-selector.disabled {
            opacity: 0.3;
            pointer-events: none;
        }

        .levels-label {
            font-size: 11px;
            color: #999;
        }

        .level-checkboxes {
            display: flex;
            gap: 4px;
        }

        .level-checkbox-wrapper {
            position: relative;
            display: inline-block;
        }

        .level-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .level-checkbox-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: #666;
            pointer-events: none;
            font-weight: bold;
        }

        .level-checkbox:checked + .level-checkbox-label {
            color: #0066cc;
        }

        .btn-link {
            background: none;
            border: none;
            color: #0066cc;
            cursor: pointer;
            font-size: 11px;
            padding: 2px 6px;
            text-decoration: underline;
        }

        .btn-link:hover {
            color: #0052a3;
        }

        /* Newer level filter styles */
        .item-main {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .levels-container {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .level-all-btn, .level-none-btn {
            padding: 2px 8px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 3px;
            color: #aaa;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s;
        }

        .level-all-btn:hover, .level-none-btn:hover {
            background: #4a4a4a;
            color: #fff;
        }

        label.level-checkbox {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background 0.2s;
        }

        label.level-checkbox:hover {
            background: #3a3a3a;
        }

        label.level-checkbox input[type="checkbox"] {
            width: 14px;
            height: 14px;
            margin: 0;
            cursor: pointer;
        }

        label.level-checkbox span {
            font-size: 11px;
            color: #aaa;
            user-select: none;
        }

        label.level-checkbox input[type="checkbox"]:checked + span {
            color: #0066cc;
            font-weight: bold;
        }

        .custom-container, .notify-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .custom-checkbox, .notify-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .notify-label {
            font-size: 11px;
            color: #999;
        }

        /* Skill picker styles */
        .skill-picker-container {
            margin-top: 10px;
        }

        .class-section {
            margin-bottom: 15px;
            background: #252525;
            border-radius: 6px;
            overflow: hidden;
        }

        .class-header {
            padding: 12px 15px;
            background: #333;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            border-bottom: 1px solid #444;
        }

        .class-header:hover {
            background: #3a3a3a;
        }

        .class-name {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .class-toggle {
            font-size: 18px;
            color: #999;
            transition: transform 0.2s;
        }

        .class-section.expanded .class-toggle {
            transform: rotate(90deg);
        }

        .class-content {
            display: none;
            padding: 10px;
        }

        .class-section.expanded .class-content {
            display: block;
        }

        .tree-section {
            margin-bottom: 10px;
            background: #2a2a2a;
            border-radius: 4px;
            overflow: hidden;
        }

        .tree-header {
            padding: 10px 12px;
            background: #2f2f2f;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .tree-header:hover {
            background: #353535;
        }

        .tree-name {
            font-size: 13px;
            font-weight: 500;
            color: #ddd;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tree-toggle {
            font-size: 14px;
            color: #888;
            transition: transform 0.2s;
        }

        .tree-section.expanded .tree-toggle {
            transform: rotate(90deg);
        }

        .tree-content {
            display: none;
            padding: 8px;
        }

        .tree-section.expanded .tree-content {
            display: block;
        }

        .skill-item {
            padding: 8px 10px;
            background: #252525;
            border-radius: 3px;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 4px;
        }

        .skill-item:hover {
            background: #2a2a2a;
        }

        .skill-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #4a90e2;
        }

        .skill-name {
            font-size: 13px;
            color: #ddd;
            flex: 1;
        }

        .skill-id {
            font-size: 11px;
            color: #666;
            font-family: monospace;
        }

        .tree-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #4a90e2;
        }

        .class-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #4a90e2;
        }

        .utility-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #252525;
            border-radius: 6px;
        }

        .utility-btn {
            padding: 6px 12px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 4px;
            color: #ddd;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .utility-btn:hover {
            background: #454545;
        }

        #enhanced-import-menu, #enhanced-import-menu * {
            pointer-events: auto;
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>PoD FilterBuilder - Visual Filter Builder - Beta Version</h1>
            <div class="subtitle">Point-and-click interface for creating simple Path of Diablo item filters</div>
            <div class="subtitle" style="color: #ff4444;">Limited testing done, use at your own risk. Testing and feedback is welcome!</div>
            <div style="text-align: center; margin-top: 10px;">
                <a href="filter-builder-about.html" style="color: #4fc3f7; text-decoration: none; font-size: 14px;" target="_blank">ℹ️ About & Help</a>
            </div>
        <!-- Legacy Import UI (can be commented out if not needed) -->
        <div id="legacy-import-container" style="margin: 20px 0; padding: 12px; border: 1px solid #555; background: #181818; border-radius: 8px;">
            <h4 style="margin: 0 0 8px 0; color: #f5c542;">Legacy Import (The one that works)</h4>
            <input type="file" id="legacy-import-file" accept=".filter,.txt,.json" style="display:none;" onchange="importLegacyFilter(event)" />
            <button onclick="document.getElementById('legacy-import-file').click();" style="margin-left: 8px;">Choose File & Import (Legacy)</button>
            <div style="font-size: 12px; color: #aaa; margin-top: 4px;">This will overwrite all filter settings. Use only for full filter file imports.</div>
        </div>
 <!--           <div style="text-align: right; ">
                <label title="Surprise only applies to exported filters">
                    <input type="checkbox" id="surprise-me" onchange="toggleSurpriseMe(this.checked)">
                        Surprise me
                </label>
            </div> -->
        </header>

        <div class="layout">
            <div class="editor-panel">
                <!-- Global Settings -->
                <div class="global-settings">
                    <h3>Global Settings</h3>
                    <div>
                        <label>
                            <input type="checkbox" id="enable-filter-levels" onchange="toggleFilterLevels(this.checked)" unchecked>
                            Enable Filter Levels (1-10)
                        </label>
                    </div>
                    <div class="filter-levels-config" id="filter-levels-config">
                        <p style="font-size: 12px; color: #999; margin: 0 0 10px 0;">Name your filter levels (used for strictness control, only named filterlevels will be used):</p>
                        <div class="level-names-grid" id="level-names-grid">
                            <!-- Level name inputs will be generated here -->
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <label title="Hides inferior (INF) items">
                            <input type="checkbox" id="hide-junk" onchange="toggleHideJunk(this.checked)" checked>
                            Hide Junk (cracked, crude, damaged)
                        </label>
                    </div>
                    <div style="margin-top: 8px;">
                        <label title="Shows anything not explicitly hidden by another line">
                            <input type="checkbox" id="show-all" onchange="toggleShowAll(this.checked)" checked>
                            End the filter with show anything not explicitly hidden
                        </label>
                    </div>
<!--                    <div style="margin-top: 8px;">
                        <label title="Surprise only applies to exported filters">
                            <input type="checkbox" id="surprise-me" onchange="toggleSurpriseMe(this.checked)">
                            Surprise me
                        </label>
                    </div> -->
                    
                    <!-- Skill-Based Filtering -->
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #444;">
                        <div style="margin-bottom: 10px; cursor: pointer; user-select: none;" onclick="toggleSkillSettings()">
                            <span id="skill-settings-toggle" style="display: inline-block; transition: transform 0.2s; margin-right: 5px;">▶</span>
                            <strong>Show +Skills on Filtered Items</strong>
                        </div>
                        <div id="skill-settings-content" style="display: none;">
                            <p style="font-size: 12px; color: #999; margin: 0 0 10px 0;">
                                Select which skills you want to show on class-specific items (applies to NMAG, Magic, Rare, and Crafted items)
                            </p>
                            
                            <!-- Skill picker will be inserted here -->
                            <div id="skill-picker-container">
                                <div style="padding: 10px; background: #2a2a2a; border-radius: 4px; color: #999; text-align: center;">
                                    Loading skill configuration...
                                </div>
                            </div>
                        </div>
                    </div>
<!--                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #444;">
                        <div style="margin-bottom: 10px; cursor: pointer; user-select: none;" onclick="toggleCommunityModulesSettings()">
                            <span id="community-modules-settings-toggle" style="display: inline-block; transition: transform 0.2s; margin-right: 5px;">▶</span>
                            <strong>Community Modules</strong>
                        </div>
                        <div id="community-modules-settings-content" style="display: none;">
                            <p style="font-size: 12px; color: #999; margin: 0 0 10px 0;">
                                Preset options created by community members. Pick and choose individual rules below:
                            </p>
                            <div id="community-modules-container">
                                <div style="padding: 10px; background: #2a2a2a; border-radius: 4px; color: #999; text-align: center;">
                                    Loading community modules...
                                </div>
                            </div>
                        </div>
                    </div> -->
                </div>

                <!-- Utility Items Section -->
                <div class="section" id="utility-section">
                    <div class="section-header" onclick="toggleSection('utility-section')">
                        <div>
                            <span class="section-title">Utility Items</span>
                            <span class="item-count" id="utility-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyUtilityPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                                <option value="essential-only">Essential Only (Potions + Scrolls)</option>
                                <option value="endgame">Endgame (Hide low potions)</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('utility', 'Utility Items')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="utility-items"></div>
                    </div>
                </div>

                <!-- Runes Section -->
                <div class="section" id="runes-section">
                    <div class="section-header" onclick="toggleSection('runes-section')">
                        <div>
                            <span class="section-title">Runes</span>
                            <span class="item-count" id="runes-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyRunePreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                                <option value="hide-low">Hide Low Runes (El-Ort)</option>
                                <option value="mid-plus">Mid+ Runes Only (Thul+)</option>
                                <option value="high-only">High Runes Only (Pul+)</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('runes', 'Runes')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="runes-items"></div>
                    </div>
                </div>

                <!-- Gems Section -->
                <div class="section" id="gems-section">
                    <div class="section-header" onclick="toggleSection('gems-section')">
                        <div>
                            <span class="section-title">Gems</span>
                            <span class="item-count" id="gems-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyGemPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                                <option value="perfect-only">Perfect Only</option>
                                <option value="flawless-plus">Flawless+</option>
                                <option value="regular-plus">Regular+</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('gems', 'Gems')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="gems-items"></div>
                    </div>
                </div>

                <!-- PoD/Keys/Maps/Quest & Misc Section -->
                <div class="section" id="misc-section">
                    <div class="section-header" onclick="toggleSection('misc-section')">
                        <div>
                            <span class="section-title">PoD/Keys/Maps/Quest & Misc Items</span>
                            <span class="item-count" id="misc-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyMiscPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                                <option value="essentials">Essentials (Keys/Organs/Essences/Orbs)</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('misc', 'PoD/Keys/Maps/Quest & Misc Items')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="misc-items"></div>
                    </div>
                </div>

                <!-- Unique Jewelry & Charms Section -->
                <div class="section" id="jewelry-charms-section">
                    <div class="section-header" onclick="toggleSection('jewelry-charms-section')">
                        <div>
                            <span class="section-title">Unique Jewelry & Charms</span>
                            <span class="item-count" id="jewelry-charms-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyJewelryCharmsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all" disabled title="Disabled to prevent accidentally hiding valuable unique jewelry and charms">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('jewelry-charms', 'Unique Jewelry & Charms')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="jewelry-charms-items"></div>
                    </div>
                </div>

                <!-- Class-Specific Uniques Section -->
                <div class="section" id="class-uniques-section">
                    <div class="section-header" onclick="toggleSection('class-uniques-section')">
                        <div>
                            <span class="section-title">Class-Specific Unique Items</span>
                            <span class="item-count" id="class-uniques-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyClassUniquesPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('class-uniques', 'Class-Specific Unique Items')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="class-uniques-items"></div>
                    </div>
                </div>

                <!-- Elite Unique Weapons Section -->
                <div class="section" id="elite-weapons-section">
                    <div class="section-header" onclick="toggleSection('elite-weapons-section')">
                        <div>
                            <span class="section-title">Elite Unique Weapons</span>
                            <span class="item-count" id="elite-weapons-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyEliteWeaponsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('elite-weapons', 'Elite Unique Weapons')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="elite-weapons-items"></div>
                    </div>
                </div>

                <!-- Elite Unique Armor Section -->
                <div class="section" id="elite-armor-section">
                    <div class="section-header" onclick="toggleSection('elite-armor-section')">
                        <div>
                            <span class="section-title">Elite Unique Armor</span>
                            <span class="item-count" id="elite-armor-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyEliteArmorPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('elite-armor', 'Elite Unique Armor')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="elite-armor-items"></div>
                    </div>
                </div>

                <!-- Exceptional Unique Weapons Section -->
                <div class="section" id="exc-weapons-section">
                    <div class="section-header" onclick="toggleSection('exc-weapons-section')">
                        <div>
                            <span class="section-title">Exceptional Unique Weapons</span>
                            <span class="item-count" id="exc-weapons-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyExcWeaponsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('exc-weapons', 'Exceptional Unique Weapons')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="exc-weapons-items"></div>
                    </div>
                </div>

                <!-- Exceptional Unique Armor Section -->
                <div class="section" id="exc-armor-section">
                    <div class="section-header" onclick="toggleSection('exc-armor-section')">
                        <div>
                            <span class="section-title">Exceptional Unique Armor</span>
                            <span class="item-count" id="exc-armor-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyExcArmorPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('exc-armor', 'Exceptional Unique Armor')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="exc-armor-items"></div>
                    </div>
                </div>

                <!-- Normal Unique Weapons Section -->
                <div class="section" id="norm-weapons-section">
                    <div class="section-header" onclick="toggleSection('norm-weapons-section')">
                        <div>
                            <span class="section-title">Normal Unique Weapons</span>
                            <span class="item-count" id="norm-weapons-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNormWeaponsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('norm-weapons', 'Normal Unique Weapons')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="norm-weapons-items"></div>
                    </div>
                </div>

                <!-- Normal Unique Armor Section -->
                <div class="section" id="norm-armor-section">
                    <div class="section-header" onclick="toggleSection('norm-armor-section')">
                        <div>
                            <span class="section-title">Normal Unique Armor</span>
                            <span class="item-count" id="norm-armor-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNormArmorPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('norm-armor', 'Normal Unique Armor')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="norm-armor-items"></div>
                    </div>
                </div>

                <!-- High-Level Sets Section -->
                <div class="section" id="high-sets-section">
                    <div class="section-header" onclick="toggleSection('high-sets-section')">
                        <div>
                            <span class="section-title">High-Level Set Items</span>
                            <span class="item-count" id="high-sets-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyHighSetsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('high-sets', 'High-Level Set Items')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="high-sets-items"></div>
                    </div>
                </div>

                <!-- Mid-Level Sets Section -->
                <div class="section" id="mid-sets-section">
                    <div class="section-header" onclick="toggleSection('mid-sets-section')">
                        <div>
                            <span class="section-title">Mid-Level Set Items</span>
                            <span class="item-count" id="mid-sets-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyMidSetsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('mid-sets', 'Mid-Level Set Items')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="mid-sets-items"></div>
                    </div>
                </div>

                <!-- Low-Level Sets Section -->
                <div class="section" id="low-sets-section">
                    <div class="section-header" onclick="toggleSection('low-sets-section')">
                        <div>
                            <span class="section-title">Low-Level Set Items</span>
                            <span class="item-count" id="low-sets-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyLowSetsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('low-sets', 'Low-Level Set Items')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="low-sets-items"></div>
                    </div>
                </div>

                <!-- Magic Jewelry Section -->
                <div class="section" id="magic-jewelry-section">
                    <div class="section-header" onclick="toggleSection('magic-jewelry-section')">
                        <div>
                            <span class="section-title">Magic Jewelry & Jewels</span>
                            <span class="item-count" id="magic-jewelry-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyMagicJewelryPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                                <option value="high-ilvl">High ILVL Only</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('magic-jewelry', 'Magic Jewelry & Jewels')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="magic-jewelry-items"></div>
                    </div>
                </div>

                <!-- Magic Charms Section -->
                <div class="section" id="magic-charms-section">
                    <div class="section-header" onclick="toggleSection('magic-charms-section')">
                        <div>
                            <span class="section-title">Magic Charms</span>
                            <span class="item-count" id="magic-charms-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyMagicCharmsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                                <option value="high-ilvl">High ILVL Only</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('magic-charms', 'Magic Charms')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="magic-charms-items"></div>
                    </div>
                </div>

                <!-- Magic Crafting Bases Section -->
                <div class="section" id="magic-crafting-section">
                    <div class="section-header" onclick="toggleSection('magic-crafting-section')">
                        <div>
                            <span class="section-title">Magic Crafting Bases</span>
                            <span class="item-count" id="magic-crafting-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyMagicCraftingPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('magic-crafting', 'Magic Crafting Bases')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="magic-crafting-items"></div>
                    </div>
                </div>

                <!-- Rare Jewelry Section -->
                <div class="section" id="rare-jewelry-section">
                    <div class="section-header" onclick="toggleSection('rare-jewelry-section')">
                        <div>
                            <span class="section-title">Rare Jewelry, Jewels, Misc</span>
                            <span class="item-count" id="rare-jewelry-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyRareJewelryPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('rare-jewelry', 'Rare Jewelry & Jewels')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="rare-jewelry-items"></div>
                    </div>
                </div>

                <!-- Rare Class Items Section -->
                <div class="section" id="rare-class-items-section">
                    <div class="section-header" onclick="toggleSection('rare-class-items-section')">
                        <div>
                            <span class="section-title">Rare Class-Specific Items</span>
                            <span class="item-count" id="rare-class-items-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyRareClassItemsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('rare-class-items', 'Rare Class-Specific Items')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="rare-class-items-items"></div>
                    </div>
                </div>

                <!-- Rare Elite Bases Section -->
                <div class="section" id="rare-elite-bases-section">
                    <div class="section-header" onclick="toggleSection('rare-elite-bases-section')">
                        <div>
                            <span class="section-title">Rare Elite Bases</span>
                            <span class="item-count" id="rare-elite-bases-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyRareEliteBasesPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('rare-elite-bases', 'Rare Elite Bases')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="rare-elite-bases-items"></div>
                    </div>
                </div>

                <!-- NMAG +skill BASES -->
                <div class="section-divider" style="margin: 30px 0; text-align: center; color: #666; font-weight: bold; font-size: 16px;">
                    === Class-specific bases and items with class +skills NMAG ===
                </div>

                <!-- Amazon +Skills -->
                <div class="section" id="nmag-amazon-skills-section">
                    <div class="section-header" onclick="toggleSection('nmag-amazon-skills-section')">
                        <div>
                            <span class="section-title">NMAG: Amazon Only or +Skills (Bows, Javelins, Spears)</span>
                            <span class="item-count" id="nmag-amazon-skills-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagAmazonSkillsPreset(this.value)">
                                <option value="">-- Select --</option>
                                <option value="all">All Items</option>
                                <option value="none">None</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-amazon-skills', 'NMAG: Amazon Only or +Skills')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-amazon-skills-items"></div>
                    </div>
                </div>

                <!-- Assassin +Skills -->
                <div class="section" id="nmag-assassin-skills-section">
                    <div class="section-header" onclick="toggleSection('nmag-assassin-skills-section')">
                        <div>
                            <span class="section-title">NMAG: Assassin Only or +Skills (Claws)</span>
                            <span class="item-count" id="nmag-assassin-skills-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagAssassinSkillsPreset(this.value)">
                                <option value="">-- Select --</option>
                                <option value="all">All Items</option>
                                <option value="elite">Elite Only</option>
                                <option value="none">None</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-assassin-skills', 'NMAG: Assassin Only or +Skills')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-assassin-skills-items"></div>
                    </div>
                </div>

                <!-- Barbarian +Skills -->
                <div class="section" id="nmag-barbarian-skills-section">
                    <div class="section-header" onclick="toggleSection('nmag-barbarian-skills-section')">
                        <div>
                            <span class="section-title">NMAG: Barbarian Only or +Skills (Barbarian Helms)</span>
                            <span class="item-count" id="nmag-barbarian-skills-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagBarbarianSkillsPreset(this.value)">
                                <option value="">-- Select --</option>
                                <option value="all">All Items</option>
                                <option value="elite">Elite Only</option>
                                <option value="none">None</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-barbarian-skills', 'NMAG: Barbarian Only or +Skills')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-barbarian-skills-items"></div>
                    </div>
                </div>

                <!-- Druid +Skills -->
                <div class="section" id="nmag-druid-skills-section">
                    <div class="section-header" onclick="toggleSection('nmag-druid-skills-section')">
                        <div>
                            <span class="section-title">NMAG: Druid Only or +Skills (Druid Pelts)</span>
                            <span class="item-count" id="nmag-druid-skills-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagDruidSkillsPreset(this.value)">
                                <option value="">-- Select --</option>
                                <option value="all">All Items</option>
                                <option value="elite">Elite Only</option>
                                <option value="none">None</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-druid-skills', 'NMAG: Druid Only or +Skills')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-druid-skills-items"></div>
                    </div>
                </div>

                <!-- Necromancer +Skills -->
                <div class="section" id="nmag-necromancer-skills-section">
                    <div class="section-header" onclick="toggleSection('nmag-necromancer-skills-section')">
                        <div>
                            <span class="section-title">NMAG: Necromancer Only or +Skills (Shrunken Heads and Wands)</span>
                            <span class="item-count" id="nmag-necromancer-skills-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagNecromancerSkillsPreset(this.value)">
                                <option value="">-- Select --</option>
                                <option value="all">All Items</option>
                                <option value="elite">Elite Only</option>
                                <option value="none">None</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-necromancer-skills', 'NMAG: Necromancer Only or +Skills')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-necromancer-skills-items"></div>
                    </div>
                </div>

                <!-- Paladin +Skills -->
                <div class="section" id="nmag-paladin-skills-section">
                    <div class="section-header" onclick="toggleSection('nmag-paladin-skills-section')">
                        <div>
                            <span class="section-title">NMAG: Paladin Only or +Skills (Shields, Scepters)</span>
                            <span class="item-count" id="nmag-paladin-skills-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagPaladinSkillsPreset(this.value)">
                                <option value="">-- Select --</option>
                                <option value="all">All Items</option>
                                <option value="elite">Elite Only</option>
                                <option value="shields">Shields Only</option>
                                <option value="scepters">Scepters Only</option>
                                <option value="none">None</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-paladin-skills', 'NMAG: Paladin Only or +Skills')">⚙ Group Settings</button>
                        </div>
                        <div style="padding: 10px; border-bottom: 1px solid #444; margin-bottom: 10px;">
                            <div style="font-weight: bold; margin-bottom: 8px; color: #4a9eff;">Show All Resistances:</div>
                            <label style="display: block; margin-bottom: 5px;">
                                <input type="checkbox" onchange="togglePaladinResistance('high', this.checked)"> 
                                High (>39)
                            </label>
                            <label style="display: block; margin-bottom: 5px;">
                                <input type="checkbox" onchange="togglePaladinResistance('mid', this.checked)"> 
                                Mid (30-39)
                            </label>
                            <label style="display: block; margin-bottom: 5px;">
                                <input type="checkbox" onchange="togglePaladinResistance('low', this.checked)"> 
                                Low (<30)
                            </label>
                        </div>
                        <div class="item-list" id="nmag-paladin-skills-items"></div>
                    </div>
                </div>

                <!-- Sorceress +Skills -->
                <div class="section" id="nmag-sorceress-skills-section">
                    <div class="section-header" onclick="toggleSection('nmag-sorceress-skills-section')">
                        <div>
                            <span class="section-title">NMAG: Sorceress Only or +Skills (Orbs, Staves)</span>
                            <span class="item-count" id="nmag-sorceress-skills-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagSorceressSkillsPreset(this.value)">
                                <option value="">-- Select --</option>
                                <option value="all">All Items</option>
                                <option value="elite">Elite Only</option>
                                <option value="ignore-2-soc">Ignore 2-Socket Max</option>
                                <option value="orbs">Orbs Only</option>
                                <option value="staves">Staves Only</option>
                                <option value="none">None</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-sorceress-skills', 'NMAG: Sorceress Only or +Skills')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-sorceress-skills-items"></div>
                    </div>
                </div>


                <!-- NMAG RUNEWORD BASES -->
                <div class="section-divider" style="margin: 30px 0; text-align: center; color: #666; font-weight: bold; font-size: 16px;">
                    === Popular Runeword bases NMAG ===
                </div>

                <!-- Weapons -->
                <div class="section" id="nmag-polearms-section">
                    <div class="section-header" onclick="toggleSection('nmag-polearms-section')">
                        <div>
                            <span class="section-title">NMAG: Polearms (Insight, Infinity, Obedience)</span>
                            <span class="item-count" id="nmag-polearms-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagPolearmsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                                <option value="elite-only">Elite Only</option>
                                <option value="eth-only">ETH Only</option>
                                <option value="4sock">4-Socket Only</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-polearms', 'NMAG: Polearms')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-polearms-items"></div>
                    </div>
                </div>

                <div class="section" id="nmag-swords-section">
                    <div class="section-header" onclick="toggleSection('nmag-swords-section')">
                        <div>
                            <span class="section-title">NMAG: Swords (Spirit, Grief)</span>
                            <span class="item-count" id="nmag-swords-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagSwordsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                                <option value="elite-only">Elite Only</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-swords', 'NMAG: Swords')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-swords-items"></div>
                    </div>
                </div>

                <div class="section" id="nmag-axes-section">
                    <div class="section-header" onclick="toggleSection('nmag-axes-section')">
                        <div>
                            <span class="section-title">NMAG: Axes (Grief, Beast, Death)</span>
                            <span class="item-count" id="nmag-axes-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagAxesPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-axes', 'NMAG: Axes')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-axes-items"></div>
                    </div>
                </div>

                <div class="section" id="nmag-maces-section">
                    <div class="section-header" onclick="toggleSection('nmag-maces-section')">
                        <div>
                            <span class="section-title">NMAG: Maces (BoTD, Heart of the Oak)</span>
                            <span class="item-count" id="nmag-maces-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagMacesPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-maces', 'NMAG: Maces')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-maces-items"></div>
                    </div>
                </div>

                <div class="section" id="nmag-bows-section">
                    <div class="section-header" onclick="toggleSection('nmag-bows-section')">
                        <div>
                            <span class="section-title">NMAG: Bows (Faith, Ice, Brand, Insight)</span>
                            <span class="item-count" id="nmag-bows-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagBowsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-bows', 'NMAG: Bows')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-bows-items"></div>
                    </div>
                </div>

                <div class="section" id="nmag-spears-section">
                    <div class="section-header" onclick="toggleSection('nmag-spears-section')">
                        <div>
                            <span class="section-title">NMAG: Spears (Infinity, Insight, Pride, Obedience)</span>
                            <span class="item-count" id="nmag-spears-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagSpearsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-spears', 'NMAG: Spears')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-spears-items"></div>
                    </div>
                </div>

                <!-- Armor -->
                <div class="section" id="nmag-armor-section">
                    <div class="section-header" onclick="toggleSection('nmag-armor-section')">
                        <div>
                            <span class="section-title">NMAG: Armor (Enigma, Fortitude, CoH, Bramble)</span>
                            <span class="item-count" id="nmag-armor-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagArmorPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                                <option value="elite-only">Elite Only</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-armor', 'NMAG: Armor')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-armor-items"></div>
                    </div>
                </div>

                <!-- Shields -->
                <div class="section" id="nmag-shields-generic-section">
                    <div class="section-header" onclick="toggleSection('nmag-shields-generic-section')">
                        <div>
                            <span class="section-title">NMAG: Shields - Generic (Spirit, Splendor, Rhyme)</span>
                            <span class="item-count" id="nmag-shields-generic-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applynmagShieldsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-shields-generic', 'NMAG: Shields - Generic')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-shields-generic-items"></div>
                    </div>
                </div>

                <!-- Helms & Class-Specific -->
                <div class="section" id="nmag-helms-section">
                    <div class="section-header" onclick="toggleSection('nmag-helms-section')">
                        <div>
                            <span class="section-title">NMAG: Helms (Delirium, Dream)</span>
                            <span class="item-count" id="nmag-helms-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagHelmsPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-helms', 'NMAG: Helms')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-helms-items"></div>
                    </div>
                </div>

                <div class="section" id="nmag-daggers-section">
                    <div class="section-header" onclick="toggleSection('nmag-daggers-section')">
                        <div>
                            <span class="section-title">NMAG: Daggers</span>
                            <span class="item-count" id="nmag-daggers-count">(0/0 shown)</span>
                        </div>
                        <span class="section-toggle">▶</span>
                    </div>
                    <div class="section-content">
                        <div class="preset-controls">
                            <label>Quick Preset:</label>
                            <select class="preset-select" onchange="applyNmagDaggersPreset(this.value)">
                                <option value="">-- Select Preset --</option>
                                <option value="show-all">Show All</option>
                                <option value="hide-all">Hide All</option>
                                <option value="elite-only">Elite Only</option>
                            </select>
                            <button class="group-settings-btn" onclick="openGroupSettings('nmag-daggers', 'NMAG: Daggers')">⚙ Group Settings</button>
                        </div>
                        <div class="item-list" id="nmag-daggers-items"></div>
                    </div>
                </div>

                <!-- NMAG Other base items -->
<!-- 
                <div class="section-divider" style="margin: 30px 0; text-align: center; color: #666; font-weight: bold; font-size: 16px;">
                    === Other NMAG base items to follow ===
                </div>
-->
                <!-- Extended NMAG categories -->

                <!-- ===== Other NMAG base items to follow ===== -->


            </div>

            <!-- Output Panel -->
            <div class="output-panel">
                <div class="output-section">
                    <div class="output-header">
                        <span class="output-title">Filter Output </span>
                        <div class="output-actions">
                                <!-- Enhanced Import Filter Dropdown -->
                                <div style="display: inline-block; position: relative;">
                                    <button class="btn" id="enhanced-import-btn">Custom Import Alpha ▼</button>
                                    <div id="enhanced-import-menu" style="display:none; position:absolute; top:100%; left:0; background:#222; border:1px solid #444; z-index:1000; padding:12px; min-width:260px; border-radius:6px; box-shadow:0 2px 8px #000a;">
                                        <div style="margin-bottom:8px;">
                                            <label for="import-source">Source:</label>
                                            <select id="import-source" onchange="toggleImportSource()">
                                                <option value="local">Local File</option>
                                                <option value="url">URL</option>
                                            </select>
                                        </div>
                                        <div id="local-import" class="import-method" style="margin-bottom:8px;">
                                            <label for="local-file" style="display:block; margin-bottom:4px; color:#ccc;">Click here to select a filter to import</label>
                                            <input type="file" id="local-file" accept=".filter,.txt,.json">
                                            <div id="import-file-instructions" style="font-size:12px; color:#aaa; margin-top:4px;">Work in progress.</div>
                                        </div>
                                        <div id="url-import" class="import-method" style="display:none; margin-bottom:8px;">
                                            <input type="url" id="import-url" placeholder="https://example.com/filter.filter" style="width:100%;">
                                        </div>
                                        <div style="margin-bottom:8px;">
                                            <label for="filter-sections">Sections:</label>
                                            <select id="filter-sections" multiple style="min-width:180px;">
                                                <option value="all">All Sections</option>
                                                <option value="utility-section">Utility Items</option>
                                                <option value="runes-section">Runes</option>
                                                <option value="gems-section">Gems</option>
                                                <option value="misc-section">PoD/Keys/Maps/Quest & Misc Items</option>
<!--                                                <option value="jewelry-charms-section">Unique Jewelry & Charms</option>
                                                <option value="class-uniques-section">Class-Specific Unique Items</option>
                                                <option value="elite-weapons-section">Elite Unique Weapons</option>
                                                <option value="elite-armor-section">Elite Unique Armor</option>
                                                <option value="exc-weapons-section">Exceptional Unique Weapons</option>
                                                <option value="exc-armor-section">Exceptional Unique Armor</option>
                                                <option value="norm-weapons-section">Normal Unique Weapons</option>
                                                <option value="norm-armor-section">Normal Unique Armor</option>
                                                <option value="high-sets-section">High-Level Set Items</option>
                                                <option value="mid-sets-section">Mid-Level Set Items</option>
                                                <option value="low-sets-section">Low-Level Set Items</option>
                                                <option value="magic-jewelry-section">Magic Jewelry & Jewels</option>
                                                <option value="magic-charms-section">Magic Charms</option>
                                                <option value="magic-crafting-section">Magic Crafting Bases</option>
                                                <option value="rare-jewelry-section">Rare Jewelry, Jewels, Misc</option>
                                                <option value="rare-class-items-section">Rare Class-Specific Items</option>
                                                <option value="rare-elite-bases-section">Rare Elite Bases</option> -->
                                            </select>
                                            <div id="import-section-instructions" style="font-size:12px; color:#aaa; margin-top:4px;">Select one or more sections to import. Hold Ctrl (Cmd on Mac) to select multiple.</div>
                                        </div>
                                        <button onclick="importFilter()" style="width:100%;">Import</button>
                                    </div>
                                </div>
                                <button class="btn btn-primary" onclick="exportFilter()">Export</button>
                                <button class="btn" onclick="copyToClipboard()">Copy</button>
                        </div>
                        <!-- Removed old toggleEnhancedImportMenu logic; robust JS now handles dropdown -->
                    </div>
                    <textarea class="output-textarea" id="filter-output" 
                        placeholder="Your filter will appear here... You can edit it manually."></textarea>
                    <div class="filter-info">
                        Lines: <span id="line-count">0</span> | 
                        Characters: <span id="char-count">0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- item_metadata.js no longer needed - max_sockets is stored in NMAG item arrays -->
    <!-- <script src="data/item_metadata.js"></script> -->
    
    <!-- External data file with all item arrays -->

    <script src="data/items.js"></script>
    <script src="data/skills.js"></script>

    <!-- Dynamic loader for community modules -->
    <script>
    // --- Modular Import Logic for .filter files ---
    // Helper: Parse .filter text into sections (simple header-based split)
    function parseFilterSections(filterText) {
        // Matches sections delimited by // === SECTION NAME START=== and // === SECTION NAME STOP===
        const sectionRegex = /\/\/ === ([A-Z0-9 _-]+) START===([\s\S]*?)\/\/ === \1 STOP===/g;
        let match, sections = [];
        while ((match = sectionRegex.exec(filterText)) !== null) {
            const name = match[1].trim();
            const content = match[0]; // include the markers in content for easy replacement
            sections.push({ name, content });
        }
        if (sections.length === 0) {
            // No sections found, treat as single section
            return [{ name: 'All', content: filterText }];
        }
        return sections;
    }

    // When file is picked, parse and populate section list
    document.getElementById('local-file').addEventListener('change', function (e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (evt) {
            const text = evt.target.result;
            const sections = parseFilterSections(text);
            // Populate the sections dropdown
            const select = document.getElementById('filter-sections');
            select.innerHTML = '';
            select.appendChild(new Option('All Sections', 'all'));
            sections.forEach(sec => {
                select.appendChild(new Option(sec.name, sec.name));
            });
            // Store for import
            select._filterFileSections = sections;
            select._filterFileText = text;
        };
        reader.readAsText(file);
    });

    // Enhanced importFilter: import only selected sections
    async function importFilter(event) {
        if (event && typeof event.preventDefault === 'function') event.preventDefault();
        const source = document.getElementById('import-source').value;
        let filterText = '';
        if (source === 'local') {
            const select = document.getElementById('filter-sections');
            const fileSections = select._filterFileSections;
            const fileText = select._filterFileText;
            if (!fileSections || !fileText) {
                alert('Please select a file and wait for it to load.');
                return;
            }
            const selected = Array.from(select.selectedOptions).map(opt => opt.value);
            if (selected.includes('all')) {
                // Import all sections: parse each section individually for robust state update
                const sections = fileSections;
                sections.forEach(sec => {
                    parseSectionAndUpdateState(sec.name, sec.content);
                });
                filterText = fileText;
            } else {
                // Only import selected sections
                let currentText = document.getElementById('filter-output').value;
                let newSections = fileSections.filter(sec => selected.includes(sec.name));
                newSections.forEach(sec => {
                    parseSectionAndUpdateState(sec.name, sec.content);
                    // Optionally update the output textarea for user feedback
                    const sectionRegex = new RegExp(`// === ${sec.name} START===([\s\S]*?)// === ${sec.name} STOP===`, 'g');
                    if (sectionRegex.test(currentText)) {
                        currentText = currentText.replace(sectionRegex, sec.content);
                    } else {
                        currentText += '\n\n' + sec.content;
                    }
                });
                filterText = currentText;
            }
        } else if (source === 'url') {
            alert('URL import not yet implemented.');
            return;
        }
        // Update the output textarea for user feedback
        document.getElementById('filter-output').value = filterText;
        document.getElementById('enhanced-import-menu').style.display = 'none';
        // Re-render all sections and update stats
        renderAllSections();
        updateOutputStats();
    }

    // Loads community modules from index.json and each module JSON
    async function loadCommunityModulesFromJSON() {
        const basePath = 'data/community_modules/';
        try {
            const indexResp = await fetch(basePath + 'index.json');
            if (!indexResp.ok) throw new Error('Failed to load index.json');
            const moduleFiles = await indexResp.json();
            const modules = {};
            for (const file of moduleFiles) {
                try {
                    const modResp = await fetch(basePath + file);
                    if (!modResp.ok) continue;
                    const modData = await modResp.json();
                    // Use moduleName or filename as key
                    const modKey = modData.moduleName || file.replace(/\.json$/, '');
                    modules[modKey] = modData.rules || [];
                } catch (e) { /* skip broken module */ }
            }
            window.communityModules = modules;
        } catch (e) {
            window.communityModules = {};
        }
    }
    // Load modules before UI
/*    window.addEventListener('DOMContentLoaded', function() {
        loadCommunityModulesFromJSON().then(() => {
            setTimeout(loadCommunityModulesUI, 100); // UI loader already waits 500ms, but ensure order
        });
    }); */
    </script>

    <script>
    // --- Community Modules Section Toggle ---
    function toggleCommunityModulesSettings() {
        const content = document.getElementById('community-modules-settings-content');
        const toggle = document.getElementById('community-modules-settings-toggle');
        if (content.style.display === 'none') {
            content.style.display = 'block';
            toggle.textContent = '▼';
        } else {
            content.style.display = 'none';
            toggle.textContent = '▶';
        }
    }
    </script>
    
    <script>
        // Item data arrays loaded from data/items.js

        // --- Community Modules UI Logic ---
/*        function loadCommunityModulesUI() {
    const container = document.getElementById('community-modules-container');
    container.innerHTML = '';
    if (!window.communityModules) {
        container.innerHTML = '<div style="padding:10px;color:#999;">No community modules found.</div>';
        return;
    }
    console.log('[loadCommunityModulesUI] window.communityModules:', window.communityModules);
    console.log('[loadCommunityModulesUI] filterState.communityModules:', JSON.stringify(filterState.communityModules));
    Object.entries(window.communityModules).forEach(([moduleName, rules]) => {
        const modDiv = document.createElement('div');
        modDiv.className = 'community-module-section';
        modDiv.style.marginBottom = '18px';
        modDiv.innerHTML = `<div style="font-weight:bold;color:#4fc3f7;margin-bottom:6px;">${moduleName.charAt(0).toUpperCase() + moduleName.slice(1)} Module</div>`;
        rules.forEach(rule => {
            const ruleId = `${moduleName}__${rule.id}`;
            const checked = filterState.communityModules?.[moduleName]?.[rule.id] ? 'checked' : '';
            const customName = filterState.communityModulesCustomNames?.[moduleName]?.[rule.id] || '';
            console.log(`[loadCommunityModulesUI] Checkbox for ${moduleName} / ${rule.id}:`, checked, 'raw:', filterState.communityModules?.[moduleName]?.[rule.id], 'customName:', customName);
            const safeModuleName = moduleName.replace(/'/g, "\\'");
            const safeRuleId = rule.id.replace(/'/g, "\\'");
            const ruleDiv = document.createElement('div');
            ruleDiv.className = 'community-module-rule';
            ruleDiv.style.marginBottom = '6px';
            ruleDiv.innerHTML = `
                <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                    <input type="checkbox" onchange="toggleCommunityModuleRule('${safeModuleName}','${safeRuleId}',this.checked)">
                    <span style="font-size:13px;color:#fff;">${rule.label}</span>
                    <span style="font-size:11px;color:#aaa;">by ${rule.author || moduleName}</span>
                </label>
                <div style="font-size:11px;color:#999;margin-left:24px;">${rule.description || ''}</div>
                <div style="margin-left:24px;margin-top:2px;">
                    <input type="text" style="font-size:12px;padding:2px 6px;width:220px;background:#222;color:#fff;border:1px solid #444;border-radius:3px;" placeholder="Custom name (optional)" value="${customName.replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}" oninput="updateCommunityModuleCustomName('${safeModuleName}','${safeRuleId}',this.value)">
                </div>
            `;
            modDiv.appendChild(ruleDiv);
            // Set the .checked property explicitly after adding to DOM
            setTimeout(() => {
                const checkboxes = ruleDiv.getElementsByTagName('input');
                if (checkboxes.length > 0) {
                    const checkedVal = !!filterState.communityModules?.[moduleName]?.[rule.id];
                    checkboxes[0].checked = checkedVal;
                    console.log(`[UI] Set checkbox for ${moduleName} / ${rule.id} to`, checkedVal, 'from', filterState.communityModules?.[moduleName]?.[rule.id]);
                } else {
                    console.log(`[UI] No checkbox found for ${moduleName} / ${rule.id}`);
                }
            }, 0);
        });
                // Update custom name for a community module rule
                window.updateCommunityModuleCustomName = function(moduleName, ruleId, value) {
                    if (!filterState.communityModulesCustomNames) filterState.communityModulesCustomNames = {};
                    if (!filterState.communityModulesCustomNames[moduleName]) filterState.communityModulesCustomNames[moduleName] = {};
                    filterState.communityModulesCustomNames[moduleName][ruleId] = value;
                    // Optionally, update filter output or UI as needed
                    if (typeof generateFilter === 'function') generateFilter();
                };
        container.appendChild(modDiv);
    });
        }
*/

function toggleCommunityModuleRule(moduleName, ruleId, checked) {
    console.log('[toggleCommunityModuleRule] called with:', { moduleName, ruleId, checked });
    if (!filterState.communityModules) filterState.communityModules = {};
    if (!filterState.communityModules[moduleName]) filterState.communityModules[moduleName] = {};
    filterState.communityModules[moduleName][ruleId] = checked;
    // Update filter output when a community module rule is toggled
    if (!filterState.communityModules) filterState.communityModules = {};
    if (!filterState.communityModules[moduleName]) filterState.communityModules[moduleName] = {};
    filterState.communityModules[moduleName][ruleId] = checked;
    console.log('[toggleCommunityModuleRule] filterState.communityModules:', filterState.communityModules);
    generateFilter();
    if (typeof updateOutputStats === 'function') updateOutputStats();

    // Highlight the first filter line for this rule if checked
    if (checked && window.communityModules && window.communityModules[moduleName]) {
        const rule = window.communityModules[moduleName].find(r => r.id === ruleId);
        if (rule && rule.filterLines && rule.filterLines.length > 0) {
            // Try to extract the item code from the first filter line
            const match = rule.filterLines[0].match(/ItemDisplay\[([^\]:]+)[^\]]*\]:/i);
            if (match && match[1]) {
                // If the code contains spaces (e.g., UNI uap), just use the whole match
                setTimeout(() => highlightItemInOutput(match[1]), 100);
            }
        }
    }
        }

        // (Removed redundant UI loader; UI is loaded after modules are loaded below)
        
        // Global settings state
        const globalSettings = {
            enableFilterLevels: false,
            levelNames: [
                '', '', '', '', '',
                '', '', '', '', ''
            ],
            hideJunk: true,
            showAll: true,
            selectedSkills: [], // Array of individual skill IDs
            selectedSkillGroups: [], // Array of skill group codes (ALLSK, CLSK0-6, TABSK0-50)
            paladinResistances: {
                low: false,    // RES<30
                mid: false,    // RES>29 AND RES<40
                high: false    // RES>39
            }
        };

        // Skill data loaded from data/skills.js (classSkills object)
        // Tree display names for the UI
        const treeNames = {
            universal: 'Universal Skills',
            bow: 'Bow & Crossbow',
            passive: 'Passive & Magic',
            javelin: 'Javelin & Spear',
            cold: 'Cold',
            lightning: 'Lightning',
            fire: 'Fire',
            summoning: 'Summoning',
            poison: 'Poison & Bone',
            curses: 'Curses',
            combat: 'Combat',
            offensive: 'Offensive Auras',
            defensive: 'Defensive Auras',
            warcries: 'Warcries',
            masteries: 'Masteries',
            shapeshifting: 'Shapeshifting',
            elemental: 'Elemental',
            traps: 'Traps',
            shadow: 'Shadow Disciplines',
            martial: 'Martial Arts'
        };
        
        // Class display names
        const classNames = {
            general: 'Non-Class Specific',
            amazon: 'Amazon',
            sorceress: 'Sorceress',
            necromancer: 'Necromancer',
            paladin: 'Paladin',
            barbarian: 'Barbarian',
            druid: 'Druid',
            assassin: 'Assassin'
        };

        // Map class keys to their CLSK codes
        const classSkillCodes = {
            amazon: 'CLSK0',
            sorceress: 'CLSK1',
            necromancer: 'CLSK2',
            paladin: 'CLSK3',
            barbarian: 'CLSK4',
            druid: 'CLSK5',
            assassin: 'CLSK6'
        };

        // Map tree keys to their TABSK codes
        const treeSkillCodes = {
            'amazon-bow': 'TABSK0',
            'amazon-passive': 'TABSK1',
            'amazon-javelin': 'TABSK2',
            'sorceress-fire': 'TABSK8',
            'sorceress-lightning': 'TABSK9',
            'sorceress-cold': 'TABSK10',
            'necromancer-curses': 'TABSK16',
            'necromancer-poison': 'TABSK17',
            'necromancer-summoning': 'TABSK18',
            'paladin-combat': 'TABSK24',
            'paladin-offensive': 'TABSK25',
            'paladin-defensive': 'TABSK26',
            'barbarian-combat': 'TABSK32',
            'barbarian-masteries': 'TABSK33',
            'barbarian-warcries': 'TABSK34',
            'druid-summoning': 'TABSK40',
            'druid-shapeshifting': 'TABSK41',
            'druid-elemental': 'TABSK42',
            'assassin-traps': 'TABSK48',
            'assassin-shadow': 'TABSK49',
            'assassin-martial': 'TABSK50'
        };

        // State management
        const filterState = {
            utility: {},
            runes: {},
            gems: {},
            misc: {},
            jewelryCharms: {},
            classUniques: {},
            eliteWeapons: {},
            eliteArmor: {},
            excWeapons: {},
            excArmor: {},
            normWeapons: {},
            normArmor: {},
            highSets: {},
            midSets: {},
            lowSets: {},
            magicJewelry: {},
            magicCharms: {},
            magicCrafting: {},
            rareJewelry: {},
            rareClassItems: {},
            rareEliteBases: {},
            nmagPolearms: {},
            nmagSwords: {},
            nmagAxes: {},
            nmagMaces: {},
            nmagSpears: {},
            nmagBows: {},
            nmagArmor: {},
            nmagShields: {},
            nmagHelms: {},
            nmagDruidPelts: {},
            nmagNecroHeads: {},
            nmagAssassinClaws: {},
            nmagSorcOrbs: {},
            nmagDaggers: {},
            nmagBarbarianHelms: {},
            nmagJavelins: {},
            nmagAmazonWeapons: {},
            nmagAmazonSkills: {},
            nmagAssassinSkills: {},
            nmagBarbarianSkills: {},
            nmagDruidSkills: {},
            nmagNecromancerSkills: {},
            nmagPaladinSkills: {},
            nmagSorceressSkills: {}
        };

        // Initialize utility items state
        utilityItems.forEach(item => {
            filterState.utility[item.code] = {
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'WHITE',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        // Initialize rune items state
        runeItems.forEach(item => {
            filterState.runes[item.code] = {
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'ORANGE',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        // Initialize gems state
        gemItems.forEach(item => {
            filterState.gems[item.code] = {
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'WHITE',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        // Initialize misc items state
        miscItems.forEach(item => {
            filterState.misc[item.code] = {
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'PURPLE',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        // Initialize unique items state
        jewelryAndCharms.forEach(item => {
            const key = item.name.replace(/[^a-zA-Z0-9]/g, '_');
            filterState.jewelryCharms[key] = {
                name: item.name,
                code: item.code,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'DARK_GREEN',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        classSpecificUniques.forEach(item => {
            // Use name as key since same code may be used by multiple items
            const key = item.name.replace(/[^a-zA-Z0-9]/g, '_');
            filterState.classUniques[key] = {
                name: item.name,
                code: item.code,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'DARK_GREEN',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        eliteUniqueWeapons.forEach(item => {
            const key = item.name.replace(/[^a-zA-Z0-9]/g, '_');
            filterState.eliteWeapons[key] = {
                name: item.name,
                code: item.code,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'DARK_GREEN',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        eliteUniqueArmor.forEach(item => {
            const key = item.name.replace(/[^a-zA-Z0-9]/g, '_');
            filterState.eliteArmor[key] = {
                name: item.name,
                code: item.code,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'DARK_GREEN',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        exceptionalUniqueWeapons.forEach(item => {
            const key = item.name.replace(/[^a-zA-Z0-9]/g, '_');
            filterState.excWeapons[key] = {
                name: item.name,
                code: item.code,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'DARK_GREEN',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        exceptionalUniqueArmor.forEach(item => {
            const key = item.name.replace(/[^a-zA-Z0-9]/g, '_');
            filterState.excArmor[key] = {
                name: item.name,
                code: item.code,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'DARK_GREEN',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        normalUniqueWeapons.forEach(item => {
            const key = item.name.replace(/[^a-zA-Z0-9]/g, '_');
            filterState.normWeapons[key] = {
                name: item.name,
                code: item.code,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'DARK_GREEN',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        normalUniqueArmor.forEach(item => {
            const key = item.name.replace(/[^a-zA-Z0-9]/g, '_');
            filterState.normArmor[key] = {
                name: item.name,
                code: item.code,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'DARK_GREEN',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        // Initialize state for set items
        highLevelSets.forEach(item => {
            const key = item.code + '_' + item.set;
            filterState.highSets[key] = {
                name: item.name,
                code: item.code,
                set: item.set,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'DARK_GREEN',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        midLevelSets.forEach(item => {
            const key = item.code + '_' + item.set;
            filterState.midSets[key] = {
                name: item.name,
                code: item.code,
                set: item.set,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'DARK_GREEN',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        lowLevelSets.forEach(item => {
            const key = item.code + '_' + item.set;
            filterState.lowSets[key] = {
                name: item.name,
                code: item.code,
                set: item.set,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'DARK_GREEN',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        // Initialize state for magic items
        magicJewelry.forEach((item, idx) => {
            const key = item.code + '_' + idx;
            filterState.magicJewelry[key] = {
                name: item.name,
                code: item.code,
                minIlvl: item.minIlvl,
                maxIlvl: item.maxIlvl,
                desc: item.desc,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'BLUE',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        magicCharms.forEach((item, idx) => {
            const key = item.code + '_' + idx;
            filterState.magicCharms[key] = {
                name: item.name,
                code: item.code,
                minIlvl: item.minIlvl,
                maxIlvl: item.maxIlvl,
                desc: item.desc,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'BLUE',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        magicCraftingBases.forEach((item, idx) => {
            const key = item.code + '_' + idx;
            filterState.magicCrafting[key] = {
                name: item.name,
                code: item.code,
                minIlvl: item.minIlvl,
                maxIlvl: item.maxIlvl,
                desc: item.desc,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'BLUE',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        // Initialize state for rare items
        rareJewelry.forEach((item, idx) => {
            const key = item.code + '_' + idx;
            filterState.rareJewelry[key] = {
                name: item.name,
                code: item.code,
                desc: item.desc,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'YELLOW',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        rareClassItems.forEach((item, idx) => {
            const key = item.code + '_' + idx;
            filterState.rareClassItems[key] = {
                name: item.name,
                code: item.code,
                minIlvl: item.minIlvl,
                tier: item.tier,
                desc: item.desc,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'YELLOW',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        rareEliteBases.forEach((item, idx) => {
            const key = item.code + '_' + idx;
            filterState.rareEliteBases[key] = {
                name: item.name,
                code: item.code,
                minIlvl: item.minIlvl,
                tier: item.tier,
                desc: item.desc,
                show: true,
                useCustomColors: false,
                chatNotification: false,
                useCustomName: false,
                customName: '',
                biggerClickbox: false,
                fontColor: 'YELLOW',
                borderColor: null,
                backgroundColor: null,
                filterLevels: [true, true, true, true, true, true, true, true, true, true]
            };
        });

        // Initialize NMAG runeword bases state
        const initializeNmagState = (items, stateCategory) => {
            items.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                filterState[stateCategory][key] = {
                    name: item.name,
                    code: item.code,
                    quality: item.quality,
                    rw: item.rw,
                    max_sockets: item.max_sockets || 6,
                    show: true,
                    ethFilter: 'both',  // 'both', 'eth-only', 'non-eth'
                    sockFilter: [],     // Array of selected socket counts: ['0', '3', '4', etc]
                    edFilter: 'any',    // 'any', '10+', '12+', '13+', '14+', '15'
                    useCustomColors: false,
                    chatNotification: false,
                    useCustomName: false,
                    customName: '',
                    biggerClickbox: false,
                    fontColor: 'WHITE',
                    borderColor: null,
                    backgroundColor: null,
                    filterLevels: [true, true, true, true, true, true, true, true, true, true]
                };
            });
        };

        initializeNmagState(nmagPolearms, 'nmagPolearms');
        initializeNmagState(nmagSwords, 'nmagSwords');
        initializeNmagState(nmagAxes, 'nmagAxes');
        initializeNmagState(nmagMaces, 'nmagMaces');
        initializeNmagState(nmagSpears, 'nmagSpears');
        initializeNmagState(nmagBows, 'nmagBows');
        initializeNmagState(nmagArmor, 'nmagArmor');
        initializeNmagState(nmagShields, 'nmagShields');
        initializeNmagState(nmagHelms, 'nmagHelms');
        initializeNmagState(nmagDruidPelts, 'nmagDruidPelts');
        initializeNmagState(nmagNecroHeads, 'nmagNecroHeads');
        initializeNmagState(nmagAssassinClaws, 'nmagAssassinClaws');
        initializeNmagState(nmagSorcOrbs, 'nmagSorcOrbs');
        initializeNmagState(nmagDaggers, 'nmagDaggers');
        initializeNmagState(nmagBarbarianHelms, 'nmagBarbarianHelms');
        
        // Initialize class skill sections
        const nmagAmazonSkills = nmagAmazonWeapons;
        const nmagAssassinSkills = nmagAssassinClaws;
        const nmagBarbarianSkills = nmagBarbarianHelms;
        const nmagDruidSkills = nmagDruidPelts;
        const nmagNecromancerSkills = [...nmagNecroHeads, ...nmagNecroWands];
        const nmagPaladinSkills = [...nmagPaladinShields, ...nmagPaladinScepters];
        const nmagSorceressSkills = [...nmagSorcOrbs, ...nmagSorcStaves];
        
        initializeNmagState(nmagAmazonSkills, 'nmagAmazonSkills');
        initializeNmagState(nmagAssassinSkills, 'nmagAssassinSkills');
        initializeNmagState(nmagBarbarianSkills, 'nmagBarbarianSkills');
        initializeNmagState(nmagDruidSkills, 'nmagDruidSkills');
        initializeNmagState(nmagNecromancerSkills, 'nmagNecromancerSkills');
        initializeNmagState(nmagPaladinSkills, 'nmagPaladinSkills');
        initializeNmagState(nmagSorceressSkills, 'nmagSorceressSkills');
        initializeNmagState(nmagAmazonWeapons, 'nmagAmazonWeapons');

        // Render items
        function renderUtilityItems() {
            const container = document.getElementById('utility-items');
            container.innerHTML = '';
            
            utilityItems.forEach(item => {
                const state = filterState.utility[item.code];
                const row = document.createElement('div');
                row.className = 'item-row';
                
                // Build font color options
                const fontOptions = FONT_COLORS.map(color => 
                    `<option value="${color}" ${state.fontColor === color ? 'selected' : ''}>${color}</option>`
                ).join('');
                
                // Build filter levels checkboxes (only for named levels)
                const levelCheckboxes = state.filterLevels
                    .map((checked, idx) => {
                        if (!globalSettings.levelNames[idx]) return null;
                        return `
                            <div class="level-checkbox-wrapper" title="${globalSettings.levelNames[idx]}">
                                <input type="checkbox" class="level-checkbox" 
                                    ${checked ? 'checked' : ''}
                                    onchange="updateItemLevel('utility', '${item.code}', ${idx}, this.checked)">
                                <span class="level-checkbox-label">${idx + 1}</span>
                            </div>
                        `;
                    })
                    .filter(cb => cb !== null)
                    .join('');
                
                const isModified = isItemModified(state, 'simple');
                
                row.innerHTML = `
                    <input type="checkbox" class="item-checkbox" 
                        ${state.show ? 'checked' : ''} 
                        onchange="updateItemState('utility', '${item.code}', 'show', this.checked)">
                    <span class="item-name">${item.name} (${item.code})</span>
                    <div class="levels-selector ${!globalSettings.enableFilterLevels ? 'disabled' : ''}">
                        <span class="levels-label">FilterLevels:</span>
                        <button class="btn-link" onclick="setAllLevels('utility', '${item.code}', true); event.preventDefault();" title="Select all levels">All</button>
                        <button class="btn-link" onclick="setAllLevels('utility', '${item.code}', false); event.preventDefault();" title="Deselect all levels">None</button>
                        <div class="level-checkboxes">
                            ${levelCheckboxes}
                        </div>
                    </div>
                    <button class="settings-btn ${isModified ? 'modified' : ''}" 
                        onclick="openItemSettings('utility', '${item.code}', \`${item.name}\`, 'simple')" 
                        title="Configure item settings">⚙</button>
                `;
                container.appendChild(row);
            });

            updateItemCount('utility');
        }

        function renderRuneItems() {
    const container = document.getElementById('runes-items');
    container.innerHTML = '';

    runeItems.forEach(item => {
        const state = filterState.runes[item.code];
        const row = document.createElement('div');
        row.className = 'item-row';

        // Build font color options
        const fontOptions = FONT_COLORS.map(color => 
            `<option value="${color}" ${state.fontColor === color ? 'selected' : ''}>${color}</option>`
        ).join('');

        // Build filter levels checkboxes (only for named levels)
        const levelCheckboxes = state.filterLevels
            .map((checked, idx) => {
                if (!globalSettings.levelNames[idx]) return null;
                return `
                    <div class="level-checkbox-wrapper" title="${globalSettings.levelNames[idx]}">
                        <input type="checkbox" class="level-checkbox" 
                            ${checked ? 'checked' : ''}
                            onchange="updateItemLevel('runes', '${item.code}', ${idx}, this.checked)">
                        <span class="level-checkbox-label">${idx + 1}</span>
                    </div>
                `;
            })
            .filter(cb => cb !== null)
            .join('');

        const isModified = isItemModified(state, 'simple');
        // High runes (Pul+ = r21-r33) should always be shown and cannot be hidden
        const isHighRune = item.code >= 'r21';

        row.innerHTML = `
            <input type="checkbox" class="item-checkbox" 
                ${state.show ? 'checked' : ''} 
                ${isHighRune ? 'disabled checked' : ''}
                onchange="updateItemState('runes', '${item.code}', 'show', this.checked)"
                ${isHighRune ? 'title=\"High runes cannot be hidden to prevent missing valuable drops\"' : ''}>
            <span class="item-name ${isHighRune ? 'high-rune' : ''}">${item.name}</span>
            <div class="levels-selector ${!globalSettings.enableFilterLevels ? 'disabled' : ''}">
                <span class="levels-label">FilterLevels:</span>
                <button class="btn-link" onclick="setAllLevels('runes', '${item.code}', true); event.preventDefault();" title="Select all levels">All</button>
                <button class="btn-link" onclick="setAllLevels('runes', '${item.code}', false); event.preventDefault();" title="Deselect all levels">None</button>
                <div class="level-checkboxes">
                    ${levelCheckboxes}
                </div>
            </div>
            <button class="settings-btn ${isModified ? 'modified' : ''}" 
                onclick="openItemSettings('runes', '${item.code}', \`${item.name}\`, 'simple')" 
                title="Configure item settings">⚙</button>
        `;
        container.appendChild(row);
    });

    updateItemCount('runes');
}

        function renderGemsItems() {
            const container = document.getElementById('gems-items');
            container.innerHTML = '';
            
            gemItems.forEach(item => {
                const state = filterState.gems[item.code];
                const row = document.createElement('div');
                row.className = 'item-row';
                
                // Build font color options
                const fontOptions = FONT_COLORS.map(color => 
                    `<option value="${color}" ${state.fontColor === color ? 'selected' : ''}>${color}</option>`
                ).join('');
                
                // Build filter levels checkboxes (only for named levels)
                const levelCheckboxes = state.filterLevels
                    .map((checked, idx) => {
                        if (!globalSettings.levelNames[idx]) return null;
                        return `
                            <div class="level-checkbox-wrapper" title="${globalSettings.levelNames[idx]}">
                                <input type="checkbox" class="level-checkbox" 
                                    ${checked ? 'checked' : ''}
                                    onchange="updateItemLevel('gems', '${item.code}', ${idx}, this.checked)">
                                <span class="level-checkbox-label">${idx + 1}</span>
                            </div>
                        `;
                    })
                    .filter(cb => cb !== null)
                    .join('');
                
                const isModified = isItemModified(state, 'simple');
                
                row.innerHTML = `
                    <input type="checkbox" class="item-checkbox" 
                        ${state.show ? 'checked' : ''} 
                        onchange="updateItemState('gems', '${item.code}', 'show', this.checked)">
                    <span class="item-name">${item.name} (${item.code})</span>
                    <div class="levels-selector ${!globalSettings.enableFilterLevels ? 'disabled' : ''}">
                        <span class="levels-label">FilterLevels:</span>
                        <button class="btn-link" onclick="setAllLevels('gems', '${item.code}', true); event.preventDefault();" title="Select all levels">All</button>
                        <button class="btn-link" onclick="setAllLevels('gems', '${item.code}', false); event.preventDefault();" title="Deselect all levels">None</button>
                        <div class="level-checkboxes">
                            ${levelCheckboxes}
                        </div>
                    </div>
                    <button class="settings-btn ${isModified ? 'modified' : ''}" 
                        onclick="openItemSettings('gems', '${item.code}', \`${item.name}\`, 'simple')" 
                        title="Configure item settings">⚙</button>
                `;
                container.appendChild(row);
            });

            updateItemCount('gems');
        }

        function renderMiscItems() {
            const container = document.getElementById('misc-items');
            container.innerHTML = '';
            
            miscItems.forEach(item => {
                const state = filterState.misc[item.code];
                const row = document.createElement('div');
                row.className = 'item-row';
                
                // Build font color options
                const fontOptions = FONT_COLORS.map(color => 
                    `<option value="${color}" ${state.fontColor === color ? 'selected' : ''}>${color}</option>`
                ).join('');
                
                // Build filter levels checkboxes (only for named levels)
                const levelCheckboxes = state.filterLevels
                    .map((checked, idx) => {
                        if (!globalSettings.levelNames[idx]) return null;
                        return `
                            <div class="level-checkbox-wrapper" title="${globalSettings.levelNames[idx]}">
                                <input type="checkbox" class="level-checkbox" 
                                    ${checked ? 'checked' : ''}
                                    onchange="updateItemLevel('misc', '${item.code}', ${idx}, this.checked)">
                                <span class="level-checkbox-label">${idx + 1}</span>
                            </div>
                        `;
                    })
                    .filter(cb => cb !== null)
                    .join('');
                
                const isModified = isItemModified(state, 'simple');
                
                row.innerHTML = `
                    <input type="checkbox" class="item-checkbox" 
                        ${state.show ? 'checked' : ''} 
                        onchange="updateItemState('misc', '${item.code}', 'show', this.checked)">
                    <span class="item-name">${item.name} (${item.code})</span>
                    <div class="levels-selector ${!globalSettings.enableFilterLevels ? 'disabled' : ''}">
                        <span class="levels-label">FilterLevels:</span>
                        <button class="btn-link" onclick="setAllLevels('misc', '${item.code}', true); event.preventDefault();" title="Select all levels">All</button>
                        <button class="btn-link" onclick="setAllLevels('misc', '${item.code}', false); event.preventDefault();" title="Deselect all levels">None</button>
                        <div class="level-checkboxes">
                            ${levelCheckboxes}
                        </div>
                    </div>
                    <button class="settings-btn ${isModified ? 'modified' : ''}" 
                        onclick="openItemSettings('misc', '${item.code}', \`${item.name}\`, 'simple')" 
                        title="Configure item settings">⚙</button>
                `;
                container.appendChild(row);
            });

            updateItemCount('misc');
        }

        // Helper to find item code from key for different categories
        function findItemCodeByKey(category, key, items) {
            if (!items) {
                console.warn(`findItemCodeByKey: items array is undefined for category '${category}', key:`, key);
                return null;
            }
            if (typeof key !== 'string') {
                console.warn(`findItemCodeByKey: key is not a string for category '${category}':`, key);
                return null;
            }
            const item = items.find(i => {
                const itemKey = (category === 'highSets' || category === 'midSets' || category === 'lowSets') 
                    ? i.code + '_' + i.set
                    : i.name.replace(/[^a-zA-Z0-9]/g, '_');
                return itemKey === key;
            });
            return item ? item.code : null;
        }

        // Update state and regenerate filter
        function updateItemState(category, code, property, value) {
            filterState[category][code][property] = value;
            
            // Re-render if useCustomColors changed to update UI
            if (property === 'useCustomColors') {
                if (category === 'utility') {
                    renderUtilityItems();
                } else if (category === 'runes') {
                    renderRuneItems();
                } else if (category === 'gems') {
                    renderGemsItems();
                } else if (category === 'misc') {
                    renderMiscItems();
                }
            }
            
            updateItemCount(category);
            generateFilter();
            // Delay highlighting to ensure DOM updates complete
            setTimeout(() => highlightItemInOutput(code), 100);
        }

        // Clear a color value
        function clearColor(category, code, property) {
            filterState[category][code][property] = null;
            if (category === 'utility') {
                renderUtilityItems();
            } else if (category === 'runes') {
                renderRuneItems();
            } else if (category === 'gems') {
                renderGemsItems();
            } else if (category === 'misc') {
                renderMiscItems();
            }
            generateFilter();
            setTimeout(() => highlightItemInOutput(code), 100);
        }

        // Clear font color to default
        function clearFontColor(category, code) {
            let defaultColor = 'WHITE';
            if (category === 'runes') defaultColor = 'ORANGE';
            else if (category === 'misc') defaultColor = 'PURPLE';
            
            filterState[category][code].fontColor = defaultColor;
            if (category === 'utility') {
                renderUtilityItems();
            } else if (category === 'runes') {
                renderRuneItems();
            } else if (category === 'gems') {
                renderGemsItems();
            } else if (category === 'misc') {
                renderMiscItems();
            }
            generateFilter();
            setTimeout(() => highlightItemInOutput(code), 100);
        }

        // Check if an item has been modified from defaults
        function isItemModified(state, itemType = 'simple') {
            // Check common modifications
            if (state.useCustomColors) return true;
            if (state.chatNotification) return true;
            if (state.biggerClickbox) return true;
            if (state.useCustomName) return true;
            if (state.onlyShowWhenLow) return true;
            
            // Check NMAG-specific modifications
            if (itemType === 'nmag') {
                if (state.ethFilter && state.ethFilter !== 'both') return true;
                if (state.sockFilter && state.sockFilter.length > 0) return true;
                if (state.edFilter && state.edFilter !== 'any') return true;
            }
            
            return false;
        }

        // Update settings button visual state after modifications
        function updateSettingsButtonState(category, itemKey, itemType = 'simple') {
            const state = filterState[category]?.[itemKey];
            if (!state) return;
            
            const isModified = isItemModified(state, itemType);
            
            // Find all settings buttons and update the one for this item
            const itemRows = document.querySelectorAll('.item-row');
            itemRows.forEach(row => {
                const settingsBtn = row.querySelector('.settings-btn');
                if (settingsBtn) {
                    const onclickAttr = settingsBtn.getAttribute('onclick');
                    // Check if this button belongs to our item
                    // Need to handle both single quotes in onclick and escaped single quotes in item key
                    if (onclickAttr && 
                        onclickAttr.includes(`'${category}'`) && 
                        (onclickAttr.includes(`'${itemKey}'`) || onclickAttr.includes(`'${itemKey.replace(/'/g, "\\'")}'`))) {
                        if (isModified) {
                            settingsBtn.classList.add('modified');
                        } else {
                            settingsBtn.classList.remove('modified');
                        }
                    }
                }
            });
        }

        // Update item counts
        function updateItemCount(category) {
            const state = filterState[category];
            const total = Object.keys(state).length;
            const shown = Object.values(state).filter(item => item.show).length;
            document.getElementById(`${category}-count`).textContent = `(${shown}/${total} shown)`;
        }

        // Section toggling
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            section.classList.toggle('expanded');
        }

        // Skill settings toggle
        function toggleSkillSettings() {
            const content = document.getElementById('skill-settings-content');
            const toggle = document.getElementById('skill-settings-toggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.style.transform = 'rotate(90deg)';
                
                // Build skill picker UI on first open
                if (!content.dataset.initialized) {
                    buildSkillPicker();
                    content.dataset.initialized = 'true';
                }
            } else {
                content.style.display = 'none';
                toggle.style.transform = 'rotate(0deg)';
            }
        }

        // Build the skill picker UI
        function buildSkillPicker() {
            const container = document.getElementById('skill-picker-container');
            
            // Create utility buttons
            let html = `
                <div class="utility-bar">
                    <button class="utility-btn" onclick="expandAllSkills()">Expand All</button>
                    <button class="utility-btn" onclick="collapseAllSkills()">Collapse All</button>
                    <button class="utility-btn" onclick="selectAllSkills()">Select All</button>
                    <button class="utility-btn" onclick="deselectAllSkills()">Deselect All</button>
                </div>
            `;
            
            // Add "All Skills" option at the top
            html += `
                <div style="margin-bottom: 15px; padding: 12px; background: #252525; border-radius: 6px;">
                    <label class="skill-item" style="margin: 0;">
                        <input type="checkbox" class="skill-group-checkbox" data-skill-group="ALLSK" onchange="onSkillGroupChange(this)">
                        <span class="skill-name" style="font-weight: 600; color: #fff;">+All Skills</span>
                        <span class="skill-id">ALLSK</span>
                    </label>
                </div>
            `;
            
            // Build each class section using classSkills from skills.js
            for (const [classKey, trees] of Object.entries(classSkills)) {
                const classSkillCode = classSkillCodes[classKey];
                
                html += `
                    <div class="class-section" data-class="${classKey}">
                        <div class="class-header" onclick="toggleClassSection(this)">
                            <div class="class-name">
                                <input type="checkbox" class="class-checkbox" onclick="toggleClassSkills(event, this)">
                                <span>${classNames[classKey]}</span>
                            </div>
                            <span class="class-toggle">►</span>
                        </div>
                        <div class="class-content">
                `;
                
                // Only add class +skills option if there's a class skill code (not for "general")
                if (classSkillCode) {
                    html += `
                            <!-- Class +Skills option -->
                            <div style="margin-bottom: 10px; padding: 10px; background: #2a2a2a; border-radius: 4px;">
                                <label class="skill-item" style="margin: 0;">
                                    <input type="checkbox" class="skill-group-checkbox" data-skill-group="${classSkillCode}" data-class="${classKey}" onchange="onSkillGroupChange(this)">
                                    <span class="skill-name" style="font-weight: 500;">+${classNames[classKey]} Skills</span>
                                    <span class="skill-id">${classSkillCode}</span>
                                </label>
                            </div>
                    `;
                }
                
                // Build each tree section
                for (const [treeKey, skills] of Object.entries(trees)) {
                    const treeSkillCode = treeSkillCodes[`${classKey}-${treeKey}`];
                    
                    html += `
                        <div class="tree-section" data-tree="${treeKey}">
                            <div class="tree-header" onclick="toggleTreeSection(this)">
                                <div class="tree-name">
                                    <input type="checkbox" class="tree-checkbox" onclick="toggleTreeSkills(event, this)">
                                    <span>${treeNames[treeKey]}</span>
                                </div>
                                <span class="tree-toggle">►</span>
                            </div>
                            <div class="tree-content">
                    `;
                    
                    // Only add tree +skills option if there's a tree skill code
                    if (treeSkillCode) {
                        html += `
                                <!-- Tree +Skills option -->
                                <div style="margin-bottom: 8px; padding: 8px; background: #252525; border-radius: 3px;">
                                    <label class="skill-item" style="margin: 0;">
                                        <input type="checkbox" class="skill-group-checkbox" data-skill-group="${treeSkillCode}" data-class="${classKey}" data-tree="${treeKey}" onchange="onSkillGroupChange(this)">
                                        <span class="skill-name" style="font-size: 12px;">+${treeNames[treeKey]} Skills</span>
                                        <span class="skill-id">${treeSkillCode}</span>
                                    </label>
                                </div>
                        `;
                    }
                    
                    // Build skill items
                    for (const skill of skills) {
                        const skillIdDisplay = skill.stat ? `STAT(${skill.stat})` : `SK${skill.id}`;
                        const skillDataAttr = skill.stat ? `data-skill-stat="${skill.stat}"` : `data-skill-id="${skill.id}"`;
                        
                        html += `
                            <label class="skill-item">
                                <input type="checkbox" class="skill-checkbox" ${skillDataAttr} data-class="${classKey}" data-tree="${treeKey}" onchange="onSkillCheckboxChange(this)">
                                <span class="skill-name">${skill.name}</span>
                                <span class="skill-id">${skillIdDisplay}</span>
                            </label>
                        `;
                    }
                    
                    html += `
                            </div>
                        </div>
                    `;
                }
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        // Toggle class section expand/collapse
        function toggleClassSection(header) {
            const section = header.closest('.class-section');
            section.classList.toggle('expanded');
        }

        // Toggle tree section expand/collapse
        function toggleTreeSection(header) {
            const section = header.closest('.tree-section');
            section.classList.toggle('expanded');
        }

        // Toggle all skills in a class
        function toggleClassSkills(event, checkbox) {
            event.stopPropagation();
            const classSection = checkbox.closest('.class-section');
            const skillCheckboxes = classSection.querySelectorAll('.skill-checkbox');
            
            skillCheckboxes.forEach(cb => {
                cb.checked = checkbox.checked;
            });
            
            updateTreeCheckboxes(classSection);
            updateGlobalSkillState();
            generateFilter();
        }

        // Toggle all skills in a tree
        function toggleTreeSkills(event, checkbox) {
            event.stopPropagation();
            const treeSection = checkbox.closest('.tree-section');
            const skillCheckboxes = treeSection.querySelectorAll('.skill-checkbox');
            
            skillCheckboxes.forEach(cb => {
                cb.checked = checkbox.checked;
            });
            
            const classSection = treeSection.closest('.class-section');
            updateTreeCheckboxes(classSection);
            updateGlobalSkillState();
            generateFilter();
        }

        // Update tree and class checkboxes based on skill selections
        function updateTreeCheckboxes(classSection) {
            const trees = classSection.querySelectorAll('.tree-section');
            let allTreesChecked = true;
            let someTreesChecked = false;
            
            trees.forEach(tree => {
                const treeCheckbox = tree.querySelector('.tree-checkbox');
                const skillCheckboxes = tree.querySelectorAll('.skill-checkbox');
                const checkedCount = Array.from(skillCheckboxes).filter(cb => cb.checked).length;
                
                treeCheckbox.checked = checkedCount === skillCheckboxes.length;
                treeCheckbox.indeterminate = checkedCount > 0 && checkedCount < skillCheckboxes.length;
                
                if (checkedCount === skillCheckboxes.length && skillCheckboxes.length > 0) {
                    someTreesChecked = true;
                } else if (checkedCount < skillCheckboxes.length) {
                    allTreesChecked = false;
                    if (checkedCount > 0) someTreesChecked = true;
                }
            });
            
            const classCheckbox = classSection.querySelector('.class-checkbox');
            classCheckbox.checked = allTreesChecked;
            classCheckbox.indeterminate = !allTreesChecked && someTreesChecked;
        }

        // Handle individual skill checkbox change
        function onSkillCheckboxChange(checkbox) {
            const classSection = checkbox.closest('.class-section');
            updateTreeCheckboxes(classSection);
            updateGlobalSkillState();
            generateFilter();
        }

        // Handle skill group checkbox change (ALLSK, CLSK, TABSK)
        function onSkillGroupChange(checkbox) {
            updateGlobalSkillState();
            generateFilter();
        }

        // Update global skill state arrays
        function updateGlobalSkillState() {
            // Individual skills - collect both regular skill IDs and STAT codes
            const allSkillCheckboxes = document.querySelectorAll('.skill-checkbox');
            const skills = [];
            
            allSkillCheckboxes.forEach(cb => {
                if (cb.checked) {
                    if (cb.dataset.skillId) {
                        // Regular skill ID
                        skills.push({ type: 'skill', id: parseInt(cb.dataset.skillId) });
                    } else if (cb.dataset.skillStat) {
                        // STAT code
                        skills.push({ type: 'stat', stat: parseInt(cb.dataset.skillStat) });
                    }
                }
            });
            
            globalSettings.selectedSkills = skills;
            
            // Skill groups (ALLSK, CLSK, TABSK)
            const allGroupCheckboxes = document.querySelectorAll('.skill-group-checkbox');
            globalSettings.selectedSkillGroups = Array.from(allGroupCheckboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.dataset.skillGroup);
        }

        // Toggle Paladin resistance filter options
        function togglePaladinResistance(tier, checked) {
            globalSettings.paladinResistances[tier] = checked;
            generateFilter();
        }

        // Utility functions
        function expandAllSkills() {
            document.querySelectorAll('.class-section, .tree-section').forEach(section => {
                section.classList.add('expanded');
            });
        }

        function collapseAllSkills() {
            document.querySelectorAll('.class-section, .tree-section').forEach(section => {
                section.classList.remove('expanded');
            });
        }

        function selectAllSkills() {
            document.querySelectorAll('.skill-checkbox, .skill-group-checkbox').forEach(cb => {
                cb.checked = true;
            });
            
            // Update all tree and class checkboxes
            document.querySelectorAll('.class-section').forEach(classSection => {
                updateTreeCheckboxes(classSection);
            });
            
            updateGlobalSkillState();
            generateFilter();
        }

        function deselectAllSkills() {
            document.querySelectorAll('.skill-checkbox, .skill-group-checkbox, .tree-checkbox, .class-checkbox').forEach(cb => {
                cb.checked = false;
                cb.indeterminate = false;
            });
            
            updateGlobalSkillState();
            generateFilter();
        }

        // Presets
        function applyUtilityPreset(preset) {
            if (!preset) return;

            const essentialCodes = ['rvl', 'rvs', 'hp5', 'mp5', 'tbk', 'ibk', 'tsc', 'isc'];
            const lowPotions = ['hp1', 'hp2', 'hp3', 'mp1', 'mp2', 'mp3', 'yps', 'wms', 'vps'];

            switch(preset) {
                case 'show-all':
                    Object.keys(filterState.utility).forEach(code => {
                        filterState.utility[code].show = true;
                    });
                    break;
                case 'hide-all':
                    Object.keys(filterState.utility).forEach(code => {
                        filterState.utility[code].show = false;
                    });
                    break;
                case 'essential-only':
                    Object.keys(filterState.utility).forEach(code => {
                        filterState.utility[code].show = essentialCodes.includes(code);
                    });
                    break;
                case 'endgame':
                    Object.keys(filterState.utility).forEach(code => {
                        filterState.utility[code].show = !lowPotions.includes(code);
                    });
                    break;
            }

            renderUtilityItems();
            generateFilter();
        }

        function applyRunePreset(preset) {
            if (!preset) return;

            switch(preset) {
                case 'show-all':
                    Object.keys(filterState.runes).forEach(code => {
                        filterState.runes[code].show = true;
                    });
                    break;
                case 'hide-all':
                    Object.keys(filterState.runes).forEach(code => {
                        // Never hide high runes (Pul+ = r21-r33) to prevent users from missing valuable drops
                        if (code < 'r21') {
                            filterState.runes[code].show = false;
                        }
                    });
                    break;
                case 'hide-low':
                    runeItems.forEach(item => {
                        filterState.runes[item.code].show = item.code > 'r09'; // After Ort
                    });
                    break;
                case 'mid-plus':
                    runeItems.forEach(item => {
                        filterState.runes[item.code].show = item.code >= 'r10'; // Thul+
                    });
                    break;
                case 'high-only':
                    runeItems.forEach(item => {
                        filterState.runes[item.code].show = item.code >= 'r21'; // Pul+
                    });
                    break;
            }

            renderRuneItems();
            generateFilter();
        }

        function applyGemPreset(preset) {
            if (!preset) return;

            switch(preset) {
                case 'show-all':
                    Object.keys(filterState.gems).forEach(code => {
                        filterState.gems[code].show = true;
                    });
                    break;
                case 'hide-all':
                    Object.keys(filterState.gems).forEach(code => {
                        filterState.gems[code].show = false;
                    });
                    break;
                case 'perfect-only':
                    gemItems.forEach(item => {
                        filterState.gems[item.code].show = item.level === 5;
                    });
                    break;
                case 'flawless-plus':
                    gemItems.forEach(item => {
                        filterState.gems[item.code].show = item.level >= 4;
                    });
                    break;
                case 'regular-plus':
                    gemItems.forEach(item => {
                        filterState.gems[item.code].show = item.level >= 3;
                    });
                    break;
            }

            renderGemsItems();
            generateFilter();
        }

        function applyMiscPreset(preset) {
            if (!preset) return;

            const essentials = ['cx5', 'cx9', 'pk1', 'pk2', 'pk3', 'dhn', 'bey', 'mbr', 'tes', 'ceh', 'bet', 'fed'];

            switch(preset) {
                case 'show-all':
                    Object.keys(filterState.misc).forEach(code => {
                        filterState.misc[code].show = true;
                    });
                    break;
                case 'hide-all':
                    Object.keys(filterState.misc).forEach(code => {
                        filterState.misc[code].show = false;
                    });
                    break;
                case 'essentials':
                    Object.keys(filterState.misc).forEach(code => {
                        filterState.misc[code].show = essentials.includes(code);
                    });
                    break;
            }

            renderMiscItems();
            generateFilter();
        }

        // ====== UNIQUE ITEMS FUNCTIONS ======

        // Generic render function for all unique item categories
        function renderUniqueItems(items, stateCategory, containerId, countId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            items.forEach(item => {
                const key = item.name.replace(/[^a-zA-Z0-9]/g, '_');
                const state = filterState[stateCategory][key];
                
                // Skip if state doesn't exist (shouldn't happen but safety check)
                if (!state) {
                    console.error(`Missing state for ${stateCategory}.${key}`);
                    return;
                }
                
                const row = document.createElement('div');
                row.className = 'item-row';
                
                // Build filter levels checkboxes (only for named levels)
                const levelCheckboxes = state.filterLevels
                    .map((checked, idx) => {
                        if (!globalSettings.levelNames[idx]) return null;
                        return `
                            <div class="level-checkbox-wrapper" title="${globalSettings.levelNames[idx]}">
                                <input type="checkbox" class="level-checkbox" 
                                    ${checked ? 'checked' : ''}
                                    onchange="updateItemLevel('${stateCategory}', '${key}', ${idx}, this.checked)">
                                <span class="level-checkbox-label">${idx + 1}</span>
                            </div>
                        `;
                    })
                    .filter(cb => cb !== null)
                    .join('');
                
                const isModified = isItemModified(state, 'unique');
                
                row.innerHTML = `
                    <input type="checkbox" class="item-checkbox" 
                        ${state.show ? 'checked' : ''} 
                        onchange="updateUniqueItemState('${stateCategory}', '${key}', 'show', this.checked)">
                    <span class="item-name">${item.name} (${item.code})</span>
                    <div class="levels-selector ${!globalSettings.enableFilterLevels ? 'disabled' : ''}">
                        <span class="levels-label">Levels:</span>
                        <button class="btn-link" onclick="setAllLevels('${stateCategory}', '${key}', true); event.preventDefault();" title="Select all levels">All</button>
                        <button class="btn-link" onclick="setAllLevels('${stateCategory}', '${key}', false); event.preventDefault();" title="Deselect all levels">None</button>
                        <div class="level-checkboxes">
                            ${levelCheckboxes}
                        </div>
                    </div>
                    <button class="settings-btn ${isModified ? 'modified' : ''}" 
                        onclick="openItemSettings('${stateCategory}', '${key}', '${item.name.replace(/'/g, "\\'")}', 'unique')" 
                        title="Configure item settings">⚙</button>
                `;
                container.appendChild(row);
            });

            updateUniqueCount(stateCategory, countId);
        }

        function renderJewelryCharmsItems() {
            renderUniqueItems(jewelryAndCharms, 'jewelryCharms', 'jewelry-charms-items', 'jewelry-charms');
        }

        function renderClassUniquesItems() {
            renderUniqueItems(classSpecificUniques, 'classUniques', 'class-uniques-items', 'class-uniques');
        }

        function renderEliteWeaponsItems() {
            renderUniqueItems(eliteUniqueWeapons, 'eliteWeapons', 'elite-weapons-items', 'elite-weapons');
        }

        function renderEliteArmorItems() {
            renderUniqueItems(eliteUniqueArmor, 'eliteArmor', 'elite-armor-items', 'elite-armor');
        }

        function renderExcWeaponsItems() {
            renderUniqueItems(exceptionalUniqueWeapons, 'excWeapons', 'exc-weapons-items', 'exc-weapons');
        }

        function renderExcArmorItems() {
            renderUniqueItems(exceptionalUniqueArmor, 'excArmor', 'exc-armor-items', 'exc-armor');
        }

        function renderNormWeaponsItems() {
            renderUniqueItems(normalUniqueWeapons, 'normWeapons', 'norm-weapons-items', 'norm-weapons');
        }

        function renderNormArmorItems() {
            renderUniqueItems(normalUniqueArmor, 'normArmor', 'norm-armor-items', 'norm-armor');
        }

        // Generic set items rendering function (uses SET keyword instead of UNI)
        function renderSetItems(items, stateCategory, containerId, countId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            container.innerHTML = '';
            let shownCount = 0;

            items.forEach(item => {
                const key = item.code + '_' + item.set;
                const state = filterState[stateCategory][key];
                if (state.show) shownCount++;

                const row = document.createElement('div');
                row.className = 'item-row';

                // Build filter levels checkboxes (only for named levels)
                const levelCheckboxes = state.filterLevels
                    .map((checked, idx) => {
                        if (!globalSettings.levelNames[idx]) return null;
                        return `
                            <div class="level-checkbox-wrapper" title="${globalSettings.levelNames[idx]}">
                                <input type="checkbox" class="level-checkbox" 
                                    ${checked ? 'checked' : ''}
                                    onchange="updateItemLevel('${stateCategory}', '${key}', ${idx}, this.checked)">
                                <span class="level-checkbox-label">${idx + 1}</span>
                            </div>
                        `;
                    })
                    .filter(cb => cb !== null)
                    .join('');

                const isModified = isItemModified(state, 'set');

                row.innerHTML = `
                    <input type="checkbox" class="item-checkbox" ${state.show ? 'checked' : ''}
                        onchange="updateSetItemState('${stateCategory}', '${key}', 'show', this.checked)">
                    <span class="item-name"
                        ${item.req_level || item.req_strength || item.req_dexterity ?
                            `title=\"${[
                                item.req_level ? `Req. Level: ${item.req_level}` : null,
                                item.req_strength ? `Req. Str: ${item.req_strength}` : null,
                                item.req_dexterity ? `Dex: ${item.req_dexterity}` : null
                            ].filter(Boolean).join(' | ')}\"` : ''}
                    >${state.name}  (${item.code})</span>
                    <div class="levels-selector ${!globalSettings.enableFilterLevels ? 'disabled' : ''}">
                        <span class="levels-label">Levels:</span>
                        <button class="btn-link" onclick="setAllLevels('${stateCategory}', '${key}', true); event.preventDefault();" title="Select all levels">All</button>
                        <button class="btn-link" onclick="setAllLevels('${stateCategory}', '${key}', false); event.preventDefault();" title="Deselect all levels">None</button>
                        <div class="level-checkboxes">
                            ${levelCheckboxes}
                        </div>
                    </div>
                    <button class="settings-btn ${isModified ? 'modified' : ''}" 
                        onclick="openItemSettings('${stateCategory}', '${key}', '${state.name.replace(/'/g, "\\'")}', 'set')" 
                        title="Configure item settings">⚙</button>
                `;

                container.appendChild(row);
            });

            document.getElementById(countId).textContent = `(${shownCount}/${items.length} shown)`;
        }

        // Specific set rendering functions
        function renderHighSetsItems() {
            renderSetItems(highLevelSets, 'highSets', 'high-sets-items', 'high-sets-count');
        }

        function renderMidSetsItems() {
            renderSetItems(midLevelSets, 'midSets', 'mid-sets-items', 'mid-sets-count');
        }

        function renderLowSetsItems() {
            renderSetItems(lowLevelSets, 'lowSets', 'low-sets-items', 'low-sets-count');
        }

        // Generic magic/rare items rendering function
        function renderMagicRareItems(items, stateCategory, containerId, countId, defaultColor) {
            const container = document.getElementById(containerId);
            if (!container) return;

            container.innerHTML = '';
            let shownCount = 0;

            // Determine if this is magic or rare based on defaultColor
            const itemType = defaultColor === 'BLUE' ? 'magic' : 'rare';

            items.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                const state = filterState[stateCategory][key];
                if (state.show) shownCount++;

                const row = document.createElement('div');
                row.className = 'item-row';

                // Build filter levels checkboxes (only for named levels)
                const levelCheckboxes = state.filterLevels
                    .map((checked, idx) => {
                        if (!globalSettings.levelNames[idx]) return null;
                        return `
                            <div class="level-checkbox-wrapper" title="${globalSettings.levelNames[idx]}">
                                <input type="checkbox" class="level-checkbox" 
                                    ${checked ? 'checked' : ''}
                                    onchange="updateItemLevel('${stateCategory}', '${key}', ${idx}, this.checked)">
                                <span class="level-checkbox-label">${idx + 1}</span>
                            </div>
                        `;
                    })
                    .filter(cb => cb !== null)
                    .join('');

                const isModified = isItemModified(state, itemType);

                row.innerHTML = `
                    <input type="checkbox" class="item-checkbox" ${state.show ? 'checked' : ''}
                        onchange="updateMagicRareItemState('${stateCategory}', '${key}', 'show', this.checked)">
                    <span class="item-name"
                        ${item.req_level || item.req_strength || item.req_dexterity ?
                            `title=\"Req:  ${[
                                item.req_level ? `Req. Level: ${item.req_level}` : null,
                                item.req_strength ? `Req. Str: ${item.req_strength}` : null,
                                item.req_dexterity ? `Dex: ${item.req_dexterity}` : null,
                                item.movepenalty ? `Move Penalty: -${item.movepenalty} FRW` : null
                            ].filter(Boolean).join(' | ')}\"` : ''}
                    >${state.name}  (${item.code})</span>
                    <div class="levels-selector ${!globalSettings.enableFilterLevels ? 'disabled' : ''}">
                        <span class="levels-label">Levels:</span>
                        <button class="btn-link" onclick="setAllLevels('${stateCategory}', '${key}', true); event.preventDefault();" title="Select all levels">All</button>
                        <button class="btn-link" onclick="setAllLevels('${stateCategory}', '${key}', false); event.preventDefault();" title="Deselect all levels">None</button>
                        <div class="level-checkboxes">
                            ${levelCheckboxes}
                        </div>
                    </div>
                    <button class="settings-btn ${isModified ? 'modified' : ''}" 
                        onclick="openItemSettings('${stateCategory}', '${key}', '${state.name.replace(/'/g, "\\'")}', '${itemType}')" 
                        title="Configure item settings">⚙</button>
                `;

                container.appendChild(row);
            });

            document.getElementById(countId).textContent = `(${shownCount}/${items.length} shown)`;
        }

        // Specific render functions for magic/rare items
        function renderMagicJewelryItems() {
            renderMagicRareItems(magicJewelry, 'magicJewelry', 'magic-jewelry-items', 'magic-jewelry-count', 'BLUE');
        }

        function renderMagicCharmsItems() {
            renderMagicRareItems(magicCharms, 'magicCharms', 'magic-charms-items', 'magic-charms-count', 'BLUE');
        }

        function renderMagicCraftingItems() {
            renderMagicRareItems(magicCraftingBases, 'magicCrafting', 'magic-crafting-items', 'magic-crafting-count', 'BLUE');
        }

        function renderRareJewelryItems() {
            renderMagicRareItems(rareJewelry, 'rareJewelry', 'rare-jewelry-items', 'rare-jewelry-count', 'YELLOW');
        }

        function renderRareClassItemsItems() {
            renderMagicRareItems(rareClassItems, 'rareClassItems', 'rare-class-items-items', 'rare-class-items-count', 'YELLOW');
        }

        function renderRareEliteBasesItems() {
            renderMagicRareItems(rareEliteBases, 'rareEliteBases', 'rare-elite-bases-items', 'rare-elite-bases-count', 'YELLOW');
        }

        // Generate socket checkboxes based on max_sockets from item state
        function generateSocketCheckboxes(itemCode, selectedSockets, stateCategory, key) {
            // Get max sockets from state (stored from item array)
            const state = filterState[stateCategory][key];
            const maxSockets = state.max_sockets || 6;
            
            // Available socket options: 0, 2, 3, 4, 5, 6 but limited by max_sockets
            const socketOptions = ['0', '2', '3', '4', '5', '6'].filter(sock => {
                const sockNum = parseInt(sock);
                return sock === '0' || sockNum <= maxSockets;
            });
            
            let html = '<div style="display: flex; align-items: center; gap: 4px; font-size: 11px;">';
            html += '<span style="margin-right: 2px;">Sockets:</span>';
            
            socketOptions.forEach(sock => {
                const isChecked = selectedSockets.includes(sock);
                html += `
                    <label style="display: flex; align-items: center; gap: 2px; cursor: pointer;">
                        <input type="checkbox" 
                            ${isChecked ? 'checked' : ''}
                            onchange="toggleNmagSocket('${stateCategory}', '${key}', '${sock}', this.checked)"
                            style="margin: 0; cursor: pointer;">
                        <span>${sock}</span>
                    </label>
                `;
            });
            
            html += '</div>';
            return html;
        }

        // Generic NMAG runeword bases rendering function
        function renderNmagItems(items, stateCategory, containerId, countId) {
//            console.log('[renderNmagItems] stateCategory:', stateCategory, 'containerId:', containerId, 'items count:', items.length);
            const container = document.getElementById(containerId);
            if (!container) {
                console.error('[renderNmagItems] Container not found:', containerId);
                return;
            }

            container.innerHTML = '';
            let shownCount = 0;

            items.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                const state = filterState[stateCategory][key];
                if (!state) {
                    console.error('[renderNmagItems] State not found for key:', key, 'in category:', stateCategory);
                }
                if (state.show) shownCount++;

                const row = document.createElement('div');
                row.className = 'item-row';

                // Build filter levels checkboxes (only for named levels)
                const levelCheckboxes = state.filterLevels
                    .map((checked, idx) => {
                        if (!globalSettings.levelNames[idx]) return null;
                        return `
                            <div class="level-checkbox-wrapper" title="${globalSettings.levelNames[idx]}">
                                <input type="checkbox" class="level-checkbox" 
                                    ${checked ? 'checked' : ''}
                                    onchange="updateItemLevel('${stateCategory}', '${key}', ${idx}, this.checked)">
                                <span class="level-checkbox-label">${idx + 1}</span>
                            </div>
                        `;
                    })
                    .filter(cb => cb !== null)
                    .join('');

                const isModified = isItemModified(state, 'nmag');

                row.innerHTML = `
                    <input type="checkbox" class="item-checkbox" data-category="${stateCategory}" data-key="${key}" ${state.show ? 'checked' : ''}>
                    <span class="item-name" 
                        ${item.req_level || item.req_strength || item.req_dexterity || item.movepenalty?
                            `title="${[
                                item.req_level ? `Req. Level: ${item.req_level}` : null,
                                item.req_strength ? `Req. Str: ${item.req_strength}` : null,
                                item.req_dexterity ? `Dex: ${item.req_dexterity}` : null,
                                item.movepenalty ? `Move Penalty: -${item.movepenalty} FRW` : null
                            ].filter(Boolean).join(' | ')}"` : ''}
                    >${state.name}  (${item.code})</span>
                    <span style="color: #888; font-size: 11px; margin-left: 8px;">[${state.quality}]
                        ${item.req_level || item.req_strength || item.req_dexterity || item.movepenalty ?
                            `<span style=\"color:#aaa; font-size:10px; margin-left:6px;\">${[
                                item.req_level ? `Req. Level: ${item.req_level}` : null,
                                item.req_strength ? `Req. Str: ${item.req_strength}` : null,
                                item.req_dexterity ? `Dex: ${item.req_dexterity}` : null,
                                item.movepenalty ? `Move Penalty: -${item.movepenalty} FRW` : null
                            ].filter(Boolean).join(' | ')}</span>` : ''}
                    </span>
                    <div class="levels-selector ${!globalSettings.enableFilterLevels ? 'disabled' : ''}">
                        <span class="levels-label">Levels:</span>
                        <button class="btn-link" onclick="setAllLevels('${stateCategory}', '${key}', true); event.preventDefault();" title="Select all levels">All</button>
                        <button class="btn-link" onclick="setAllLevels('${stateCategory}', '${key}', false); event.preventDefault();" title="Deselect all levels">None</button>
                        <div class="level-checkboxes">
                            ${levelCheckboxes}
                        </div>
                    </div>
                    <button class="settings-btn ${isModified ? 'modified' : ''}" 
                        onclick="openItemSettings('${stateCategory}', '${key}', '${state.name.replace(/'/g, "\\'")}', 'nmag')" 
                        title="Configure item settings">⚙</button>
                `;

                // Attach event listener to checkbox after DOM creation
                const checkbox = row.querySelector('.item-checkbox');
                checkbox.addEventListener('change', function() {
                    console.log('[checkbox.change] Firing for:', stateCategory, key);
                    updateNmagItemState(stateCategory, key, 'show', this.checked);
                });

                container.appendChild(row);
            });

            const total = items.length;
            document.getElementById(countId).textContent = `(${shownCount}/${total} shown)`;
        }

        function renderNmagPolearmsItems() {
            renderNmagItems(nmagPolearms, 'nmagPolearms', 'nmag-polearms-items', 'nmag-polearms-count');
        }

        function renderNmagSwordsItems() {
            renderNmagItems(nmagSwords, 'nmagSwords', 'nmag-swords-items', 'nmag-swords-count');
        }

        function renderNmagAxesItems() {
            renderNmagItems(nmagAxes, 'nmagAxes', 'nmag-axes-items', 'nmag-axes-count');
        }

        function renderNmagMacesItems() {
            renderNmagItems(nmagMaces, 'nmagMaces', 'nmag-maces-items', 'nmag-maces-count');
        }

        function renderNmagBowsItems() {
            renderNmagItems(nmagBows, 'nmagBows', 'nmag-bows-items', 'nmag-bows-count');
        }

        function renderNmagSpearsItems() {
            renderNmagItems(nmagSpears, 'nmagSpears', 'nmag-spears-items', 'nmag-spears-count');
        }

        function renderNmagArmorItems() {
            renderNmagItems(nmagArmor, 'nmagArmor', 'nmag-armor-items', 'nmag-armor-count');
        }

        function rendernmagShieldsItems() {
            renderNmagItems(nmagShields, 'nmagShields', 'nmag-shields-generic-items', 'nmag-shields-generic-count');
        }

        function renderNmagHelmsItems() {
            renderNmagItems(nmagHelms, 'nmagHelms', 'nmag-helms-items', 'nmag-helms-count');
        }

        function renderNmagDruidPeltsItems() {
            renderNmagItems(nmagDruidPelts, 'nmagDruidPelts', 'nmag-druid-pelts-items', 'nmag-druid-pelts-count');
        }

        function renderNmagNecroHeadsItems() {
            renderNmagItems(nmagNecroHeads, 'nmagNecroHeads', 'nmag-necro-heads-items', 'nmag-necro-heads-count');
        }

        function renderNmagAssassinClawsItems() {
            renderNmagItems(nmagAssassinClaws, 'nmagAssassinClaws', 'nmag-assassin-claws-items', 'nmag-assassin-claws-count');
        }

        function renderNmagSorcOrbsItems() {
            renderNmagItems(nmagSorcOrbs, 'nmagSorcOrbs', 'nmag-sorc-orbs-items', 'nmag-sorc-orbs-count');
        }

        function renderNmagDaggersItems() {
            renderNmagItems(nmagDaggers, 'nmagDaggers', 'nmag-daggers-items', 'nmag-daggers-count');
        }

        function renderNmagBarbarianHelmsItems() {
            renderNmagItems(nmagBarbarianHelms, 'nmagBarbarianHelms', 'nmag-barbarian-helms-items', 'nmag-barbarian-helms-count');
        }

//        function renderNmagJavelinsItems() {
//            renderNmagItems(nmagJavelins, 'nmagJavelins', 'nmag-javelins-items', 'nmag-javelins-count');
//        }

        // Class skill render functions
        function renderNmagAmazonSkillsItems() {
//            console.log('[renderNmagAmazonSkillsItems] Called with nmagAmazonSkills:', nmagAmazonSkills);
            renderNmagItems(nmagAmazonSkills, 'nmagAmazonSkills', 'nmag-amazon-skills-items', 'nmag-amazon-skills-count');
        }

        function renderNmagAssassinSkillsItems() {
            renderNmagItems(nmagAssassinSkills, 'nmagAssassinSkills', 'nmag-assassin-skills-items', 'nmag-assassin-skills-count');
        }

        function renderNmagBarbarianSkillsItems() {
            renderNmagItems(nmagBarbarianSkills, 'nmagBarbarianSkills', 'nmag-barbarian-skills-items', 'nmag-barbarian-skills-count');
        }

        function renderNmagDruidSkillsItems() {
            renderNmagItems(nmagDruidSkills, 'nmagDruidSkills', 'nmag-druid-skills-items', 'nmag-druid-skills-count');
        }

        function renderNmagNecromancerSkillsItems() {
            renderNmagItems(nmagNecromancerSkills, 'nmagNecromancerSkills', 'nmag-necromancer-skills-items', 'nmag-necromancer-skills-count');
        }

        function renderNmagPaladinSkillsItems() {
            renderNmagItems(nmagPaladinSkills, 'nmagPaladinSkills', 'nmag-paladin-skills-items', 'nmag-paladin-skills-count');
        }

        function renderNmagSorceressSkillsItems() {
            renderNmagItems(nmagSorceressSkills, 'nmagSorceressSkills', 'nmag-sorceress-skills-items', 'nmag-sorceress-skills-count');
        }

        function renderNmagAmazonWeaponsItems() {
            renderNmagItems(nmagAmazonWeapons, 'nmagAmazonWeapons', 'nmag-amazon-weapons-items', 'nmag-amazon-weapons-count');
        }

        // Helper functions for unique items
        function updateUniqueItemState(category, key, field, value) {
            // Ensure filterState[category] and filterState[category][key] are initialized
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][key]) filterState[category][key] = {};
            filterState[category][key][field] = value;
            
            if (category === 'jewelryCharms') {
                renderJewelryCharmsItems();
            } else if (category === 'classUniques') {
                renderClassUniquesItems();
            } else if (category === 'eliteWeapons') {
                renderEliteWeaponsItems();
            } else if (category === 'eliteArmor') {
                renderEliteArmorItems();
            } else if (category === 'excWeapons') {
                renderExcWeaponsItems();
            } else if (category === 'excArmor') {
                renderExcArmorItems();
            } else if (category === 'normWeapons') {
                renderNormWeaponsItems();
            } else if (category === 'normArmor') {
                renderNormArmorItems();
            }
            
            generateFilter();
            
            // Find item code and highlight
            const itemArrays = {
                'jewelryCharms': jewelryAndCharms,
                'classUniques': classSpecificUniques,
                'eliteWeapons': eliteUniqueWeapons,
                'eliteArmor': eliteUniqueArmor,
                'excWeapons': exceptionalUniqueWeapons,
                'excArmor': exceptionalUniqueArmor,
                'normWeapons': normalUniqueWeapons,
                'normArmor': normalUniqueArmor
            };
            const code = findItemCodeByKey(category, key, itemArrays[category]);
            if (code) setTimeout(() => highlightItemInOutput(code, 'UNI'), 100);
        }

        function clearUniqueFontColor(category, key) {
            filterState[category][key].fontColor = 'DARK_GREEN';
            
            if (category === 'jewelryCharms') {
                renderJewelryCharmsItems();
            } else if (category === 'classUniques') {
                renderClassUniquesItems();
            } else if (category === 'eliteWeapons') {
                renderEliteWeaponsItems();
            } else if (category === 'eliteArmor') {
                renderEliteArmorItems();
            } else if (category === 'excWeapons') {
                renderExcWeaponsItems();
            } else if (category === 'excArmor') {
                renderExcArmorItems();
            } else if (category === 'normWeapons') {
                renderNormWeaponsItems();
            } else if (category === 'normArmor') {
                renderNormArmorItems();
            }
            
            generateFilter();
            
            const itemArrays = {
                'jewelryCharms': jewelryAndCharms,
                'classUniques': classSpecificUniques,
                'eliteWeapons': eliteUniqueWeapons,
                'eliteArmor': eliteUniqueArmor,
                'excWeapons': exceptionalUniqueWeapons,
                'excArmor': exceptionalUniqueArmor,
                'normWeapons': normalUniqueWeapons,
                'normArmor': normalUniqueArmor
            };
            const code = findItemCodeByKey(category, key, itemArrays[category]);
            if (code) setTimeout(() => highlightItemInOutput(code, 'UNI'), 100);
        }

        function clearUniqueColor(category, key, colorType) {
            filterState[category][key][colorType] = null;
            
            if (category === 'jewelryCharms') {
                renderJewelryCharmsItems();
            } else if (category === 'classUniques') {
                renderClassUniquesItems();
            } else if (category === 'eliteWeapons') {
                renderEliteWeaponsItems();
            } else if (category === 'eliteArmor') {
                renderEliteArmorItems();
            } else if (category === 'excWeapons') {
                renderExcWeaponsItems();
            } else if (category === 'excArmor') {
                renderExcArmorItems();
            } else if (category === 'normWeapons') {
                renderNormWeaponsItems();
            } else if (category === 'normArmor') {
                renderNormArmorItems();
            }
            
            generateFilter();
            
            const itemArrays = {
                'jewelryCharms': jewelryAndCharms,
                'classUniques': classSpecificUniques,
                'eliteWeapons': eliteUniqueWeapons,
                'eliteArmor': eliteUniqueArmor,
                'excWeapons': exceptionalUniqueWeapons,
                'excArmor': exceptionalUniqueArmor,
                'normWeapons': normalUniqueWeapons,
                'normArmor': normalUniqueArmor
            };
            const code = findItemCodeByKey(category, key, itemArrays[category]);
            if (code) setTimeout(() => highlightItemInOutput(code, 'UNI'), 100);
        }

        function updateUniqueCount(category, countId) {
            const state = filterState[category];
            const total = Object.keys(state).length;
            const shown = Object.values(state).filter(item => item.show).length;
            document.getElementById(`${countId}-count`).textContent = `(${shown}/${total} shown)`;
        }

        // Update set item state and re-render
        function updateSetItemState(category, key, field, value, index = null) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][key]) filterState[category][key] = {};
            if (index !== null) {
                if (!Array.isArray(filterState[category][key][field])) filterState[category][key][field] = [];
                filterState[category][key][field][index] = value;
            } else {
                filterState[category][key][field] = value;
            }

            // Re-render the appropriate section
            if (category === 'highSets') {
                renderHighSetsItems();
            } else if (category === 'midSets') {
                renderMidSetsItems();
            } else if (category === 'lowSets') {
                renderLowSetsItems();
            }
            
            generateFilter();
            
            const itemArrays = {
                'highSets': highLevelSets,
                'midSets': midLevelSets,
                'lowSets': lowLevelSets
            };
            const code = findItemCodeByKey(category, key, itemArrays[category]);
            if (code) setTimeout(() => highlightItemInOutput(code, 'SET'), 100);
        }

        // Clear set item font color (reset to DARK_GREEN)
        function clearSetFontColor(category, key) {
            filterState[category][key].fontColor = 'DARK_GREEN';
            if (category === 'highSets') {
                renderHighSetsItems();
            } else if (category === 'midSets') {
                renderMidSetsItems();
            } else if (category === 'lowSets') {
                renderLowSetsItems();
            }
            generateFilter();
            
            const itemArrays = {
                'highSets': highLevelSets,
                'midSets': midLevelSets,
                'lowSets': lowLevelSets
            };
            const code = findItemCodeByKey(category, key, itemArrays[category]);
            if (code) setTimeout(() => highlightItemInOutput(code, 'SET'), 100);
        }

        // Clear set item border or background color
        function clearSetColor(category, key, colorType) {
            filterState[category][key][colorType] = null;
            if (category === 'highSets') {
                renderHighSetsItems();
            } else if (category === 'midSets') {
                renderMidSetsItems();
            } else if (category === 'lowSets') {
                renderLowSetsItems();
            }
            generateFilter();
            
            const itemArrays = {
                'highSets': highLevelSets,
                'midSets': midLevelSets,
                'lowSets': lowLevelSets
            };
            const code = findItemCodeByKey(category, key, itemArrays[category]);
            if (code) setTimeout(() => highlightItemInOutput(code, 'SET'), 100);
        }

        // Set all filter levels for a set item
        function setAllSetLevels(category, key, enabled) {
            for (let i = 0; i < 10; i++) {
                filterState[category][key].filterLevels[i] = enabled;
            }
            if (category === 'highSets') {
                renderHighSetsItems();
            } else if (category === 'midSets') {
                renderMidSetsItems();
            } else if (category === 'lowSets') {
                renderLowSetsItems();
            }
            generateFilter();
            
            const itemArrays = {
                'highSets': highLevelSets,
                'midSets': midLevelSets,
                'lowSets': lowLevelSets
            };
            const code = findItemCodeByKey(category, key, itemArrays[category]);
            if (code) setTimeout(() => highlightItemInOutput(code, 'SET'), 100);
        }

        // Preset functions for unique items
        function applyUniquePreset(category, items, preset) {
            items.forEach(item => {
                const key = item.name.replace(/[^a-zA-Z0-9]/g, '_');
                if (preset === 'show-all') {
                    filterState[category][key].show = true;
                } else if (preset === 'hide-all') {
                    // Never hide unique jewelry and charms to prevent users from missing valuable items
                    if (category !== 'jewelryCharms') {
                        filterState[category][key].show = false;
                    }
                }
            });
            
            // Re-render the appropriate section
            if (category === 'jewelryCharms') {
                renderJewelryCharmsItems();
            } else if (category === 'classUniques') {
                renderClassUniquesItems();
            } else if (category === 'eliteWeapons') {
                renderEliteWeaponsItems();
            } else if (category === 'eliteArmor') {
                renderEliteArmorItems();
            } else if (category === 'excWeapons') {
                renderExcWeaponsItems();
            } else if (category === 'excArmor') {
                renderExcArmorItems();
            } else if (category === 'normWeapons') {
                renderNormWeaponsItems();
            } else if (category === 'normArmor') {
                renderNormArmorItems();
            }
            
            generateFilter();
        }

        function applyJewelryCharmsPreset(preset) {
            if (!preset) return;
            applyUniquePreset('jewelryCharms', jewelryAndCharms, preset);
        }

        function applyClassUniquesPreset(preset) {
            if (!preset) return;
            applyUniquePreset('classUniques', classSpecificUniques, preset);
        }

        function applyEliteWeaponsPreset(preset) {
            if (!preset) return;
            applyUniquePreset('eliteWeapons', eliteUniqueWeapons, preset);
        }

        function applyEliteArmorPreset(preset) {
            if (!preset) return;
            applyUniquePreset('eliteArmor', eliteUniqueArmor, preset);
        }

        function applyExcWeaponsPreset(preset) {
            if (!preset) return;
            applyUniquePreset('excWeapons', exceptionalUniqueWeapons, preset);
        }

        function applyExcArmorPreset(preset) {
            if (!preset) return;
            applyUniquePreset('excArmor', exceptionalUniqueArmor, preset);
        }

        function applyNormWeaponsPreset(preset) {
            if (!preset) return;
            applyUniquePreset('normWeapons', normalUniqueWeapons, preset);
        }

        function applyNormArmorPreset(preset) {
            if (!preset) return;
            applyUniquePreset('normArmor', normalUniqueArmor, preset);
        }

        // Preset functions for set items
        function applyHighSetsPreset(preset) {
            if (!preset) return;
            highLevelSets.forEach(item => {
                const key = item.code + '_' + item.set;
                if (preset === 'show-all') {
                    filterState.highSets[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.highSets[key].show = false;
                }
            });
            renderHighSetsItems();
            generateFilter();
        }

        function applyMidSetsPreset(preset) {
            if (!preset) return;
            midLevelSets.forEach(item => {
                const key = item.code + '_' + item.set;
                if (preset === 'show-all') {
                    filterState.midSets[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.midSets[key].show = false;
                }
            });
            renderMidSetsItems();
            generateFilter();
        }

        function applyLowSetsPreset(preset) {
            if (!preset) return;
            lowLevelSets.forEach(item => {
                const key = item.code + '_' + item.set;
                if (preset === 'show-all') {
                    filterState.lowSets[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.lowSets[key].show = false;
                }
            });
            renderLowSetsItems();
            generateFilter();
        }

        // State update functions for magic/rare items
        // Wrapper for legacy import compatibility
        function updateRareMagicItemState(category, key, state) {
            // The import logic calls this with (code, rarity, state), but updateMagicRareItemState expects (category, key, field, value, index)
            // We'll assume 'state' is an object of fields to set
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][key]) filterState[category][key] = {};
            for (const field in state) {
                filterState[category][key][field] = state[field];
            }
        }
        function updateMagicRareItemState(category, key, field, value, index = null) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][key]) filterState[category][key] = {};
            if (index !== null) {
                if (!Array.isArray(filterState[category][key][field])) filterState[category][key][field] = [];
                filterState[category][key][field][index] = value;
            } else {
                filterState[category][key][field] = value;
            }

            // Re-render the appropriate section
            if (category === 'magicJewelry') {
                renderMagicJewelryItems();
            } else if (category === 'magicCharms') {
                renderMagicCharmsItems();
            } else if (category === 'magicCrafting') {
                renderMagicCraftingItems();
            } else if (category === 'rareJewelry') {
                renderRareJewelryItems();
            } else if (category === 'rareClassItems') {
                renderRareClassItemsItems();
            } else if (category === 'rareEliteBases') {
                renderRareEliteBasesItems();
            }
            
            generateFilter();
            
            // Extract code from key format "code_index"
            const code = (typeof key === 'string' && key.includes('_')) ? key.split('_')[0] : key;
            const prefix = category.startsWith('magic') ? 'MAG' : 'RARE';
            if (code) setTimeout(() => highlightItemInOutput(code, prefix), 100);
        }

        function clearMagicRareFontColor(category, key, defaultColor) {
            filterState[category][key].fontColor = defaultColor;
            if (category === 'magicJewelry') {
                renderMagicJewelryItems();
            } else if (category === 'magicCharms') {
                renderMagicCharmsItems();
            } else if (category === 'magicCrafting') {
                renderMagicCraftingItems();
            } else if (category === 'rareJewelry') {
                renderRareJewelryItems();
            } else if (category === 'rareClassItems') {
                renderRareClassItemsItems();
            } else if (category === 'rareEliteBases') {
                renderRareEliteBasesItems();
            }
            generateFilter();
            
            const code = (typeof key === 'string' && key.includes('_')) ? key.split('_')[0] : key;
            const prefix = category.startsWith('magic') ? 'MAG' : 'RARE';
            if (code) setTimeout(() => highlightItemInOutput(code, prefix), 100);
        }

        function clearMagicRareColor(category, key, colorType) {
            filterState[category][key][colorType] = null;
            if (category === 'magicJewelry') {
                renderMagicJewelryItems();
            } else if (category === 'magicCharms') {
                renderMagicCharmsItems();
            } else if (category === 'magicCrafting') {
                renderMagicCraftingItems();
            } else if (category === 'rareJewelry') {
                renderRareJewelryItems();
            } else if (category === 'rareClassItems') {
                renderRareClassItemsItems();
            } else if (category === 'rareEliteBases') {
                renderRareEliteBasesItems();
            }
            generateFilter();
            
            const code = (typeof key === 'string' && key.includes('_')) ? key.split('_')[0] : key;
            const prefix = category.startsWith('magic') ? 'MAG' : 'RARE';
            if (code) setTimeout(() => highlightItemInOutput(code, prefix), 100);
        }

        function setAllMagicRareLevels(category, key, enabled) {
            for (let i = 0; i < 10; i++) {
                filterState[category][key].filterLevels[i] = enabled;
            }
            if (category === 'magicJewelry') {
                renderMagicJewelryItems();
            } else if (category === 'magicCharms') {
                renderMagicCharmsItems();
            } else if (category === 'magicCrafting') {
                renderMagicCraftingItems();
            } else if (category === 'rareJewelry') {
                renderRareJewelryItems();
            } else if (category === 'rareClassItems') {
                renderRareClassItemsItems();
            } else if (category === 'rareEliteBases') {
                renderRareEliteBasesItems();
            }
            generateFilter();
            
            const code = (typeof key === 'string' && key.includes('_')) ? key.split('_')[0] : key;
            const prefix = category.startsWith('magic') ? 'MAG' : 'RARE';
            if (code) setTimeout(() => highlightItemInOutput(code, prefix), 100);
        }

        // Preset functions for magic/rare items
        function applyMagicJewelryPreset(preset) {
            if (!preset) return;
            magicJewelry.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.magicJewelry[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.magicJewelry[key].show = false;
                } else if (preset === 'high-ilvl') {
                    filterState.magicJewelry[key].show = !item.maxIlvl || item.minIlvl >= 71;
                }
            });
            renderMagicJewelryItems();
            generateFilter();
        }

        function applyMagicCharmsPreset(preset) {
            if (!preset) return;
            magicCharms.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.magicCharms[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.magicCharms[key].show = false;
                } else if (preset === 'high-ilvl') {
                    filterState.magicCharms[key].show = !item.maxIlvl || item.minIlvl >= 50;
                }
            });
            renderMagicCharmsItems();
            generateFilter();
        }

        function applyMagicCraftingPreset(preset) {
            if (!preset) return;
            magicCraftingBases.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.magicCrafting[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.magicCrafting[key].show = false;
                }
            });
            renderMagicCraftingItems();
            generateFilter();
        }

        function applyRareJewelryPreset(preset) {
            if (!preset) return;
            rareJewelry.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.rareJewelry[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.rareJewelry[key].show = false;
                }
            });
            renderRareJewelryItems();
            generateFilter();
        }

        function applyRareClassItemsPreset(preset) {
            if (!preset) return;
            rareClassItems.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.rareClassItems[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.rareClassItems[key].show = false;
                }
            });
            renderRareClassItemsItems();
            generateFilter();
        }

        function applyRareEliteBasesPreset(preset) {
            if (!preset) return;
            rareEliteBases.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.rareEliteBases[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.rareEliteBases[key].show = false;
                }
            });
            renderRareEliteBasesItems();
            generateFilter();
        }

        // State update functions for NMAG items
        function updateNmagItemState(category, key, field, value, index = null) {
            // Ensure filterState[category] and filterState[category][key] are initialized
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][key]) filterState[category][key] = {};
            if (index !== null) {
                if (!Array.isArray(filterState[category][key][field])) filterState[category][key][field] = [];
                filterState[category][key][field][index] = value;
            } else {
                filterState[category][key][field] = value;
            }

            // Re-render the appropriate section
            const renderMap = {
                'nmagPolearms': renderNmagPolearmsItems,
                'nmagSwords': renderNmagSwordsItems,
                'nmagAxes': renderNmagAxesItems,
                'nmagMaces': renderNmagMacesItems,
                'nmagSpears': renderNmagSpearsItems,
                'nmagBows': renderNmagBowsItems,
                'nmagArmor': renderNmagArmorItems,
                'nmagShields': rendernmagShieldsItems,
                'nmagHelms': renderNmagHelmsItems,
                'nmagDruidPelts': renderNmagDruidPeltsItems,
                'nmagNecroHeads': renderNmagNecroHeadsItems,
                'nmagAssassinClaws': renderNmagAssassinClawsItems,
                'nmagSorcOrbs': renderNmagSorcOrbsItems,
                'nmagDaggers': renderNmagDaggersItems,
                'nmagBarbarianHelms': renderNmagBarbarianHelmsItems,
                'nmagAmazonSkills': renderNmagAmazonSkillsItems,
                'nmagPaladinSkills': renderNmagPaladinSkillsItems,
                'nmagSorceressSkills': renderNmagSorceressSkillsItems,
                'nmagDruidSkills': renderNmagDruidSkillsItems,
                'nmagBarbarianSkills': renderNmagBarbarianSkillsItems,
                'nmagNecromancerSkills': renderNmagNecromancerSkillsItems,
                'nmagAssassinSkills': renderNmagAssassinSkillsItems
            };
            if (renderMap[category]) renderMap[category]();
            generateFilter();
            
            const code = (typeof key === 'string' && key.includes('_')) ? key.split('_')[0] : key;
            // Class skill sections don't use NMAG prefix in ItemDisplay lines
            const classSkillCategories = ['nmagAmazonSkills', 'nmagPaladinSkills', 'nmagSorceressSkills', 'nmagDruidSkills', 'nmagBarbarianSkills', 'nmagNecromancerSkills', 'nmagAssassinSkills'];
            const isClassSkillItem = classSkillCategories.includes(category);
            if (code) setTimeout(() => highlightItemInOutput(code, isClassSkillItem ? null : 'NMAG'), 100);
        }

        // Toggle socket selection for NMAG items
        function toggleNmagSocket(category, key, socketValue, checked) {
            const state = filterState[category][key];
            if (checked) {
                if (!state.sockFilter.includes(socketValue)) {
                    state.sockFilter.push(socketValue);
                }
            } else {
                state.sockFilter = state.sockFilter.filter(s => s !== socketValue);
            }
            generateFilter();
            
            const code = (typeof key === 'string' && key.includes('_')) ? key.split('_')[0] : key;
            if (code) setTimeout(() => highlightItemInOutput(code, 'NMAG'), 100);
        }

        function clearNmagFontColor(category, key) {
            filterState[category][key].fontColor = 'WHITE';
            const renderMap = {
                'nmagPolearms': renderNmagPolearmsItems,
                'nmagSwords': renderNmagSwordsItems,
                'nmagAxes': renderNmagAxesItems,
                'nmagMaces': renderNmagMacesItems,
                'nmagSpears': renderNmagSpearsItems,
                'nmagBows': renderNmagBowsItems,
                'nmagArmor': renderNmagArmorItems,
                'nmagShields': rendernmagShieldsItems,
                'nmagHelms': renderNmagHelmsItems,
                'nmagDruidPelts': renderNmagDruidPeltsItems,
                'nmagNecroHeads': renderNmagNecroHeadsItems,
                'nmagAssassinClaws': renderNmagAssassinClawsItems,
                'nmagSorcOrbs': renderNmagSorcOrbsItems,
                'nmagDaggers': renderNmagDaggersItems,
                'nmagBarbarianHelms': renderNmagBarbarianHelmsItems,
//                'nmagJavelins': renderNmagJavelinsItems,
                'nmagAmazonWeapons': renderNmagAmazonWeaponsItems,
                'nmagCirclets': renderNmagCircletsItems
            };
            if (renderMap[category]) renderMap[category]();
            generateFilter();
            
            const code = (typeof key === 'string' && key.includes('_')) ? key.split('_')[0] : key;
            if (code) setTimeout(() => highlightItemInOutput(code, 'NMAG'), 100);
        }

        function clearNmagColor(category, key, colorType) {
            filterState[category][key][colorType] = null;
            const renderMap = {
                'nmagPolearms': renderNmagPolearmsItems,
                'nmagSwords': renderNmagSwordsItems,
                'nmagAxes': renderNmagAxesItems,
                'nmagMaces': renderNmagMacesItems,
                'nmagSpears': renderNmagSpearsItems,
                'nmagBows': renderNmagBowsItems,
                'nmagArmor': renderNmagArmorItems,
                'nmagShields': rendernmagShieldsItems,
               'nmagHelms': renderNmagHelmsItems,
                'nmagDruidPelts': renderNmagDruidPeltsItems,
                'nmagNecroHeads': renderNmagNecroHeadsItems,
                'nmagAssassinClaws': renderNmagAssassinClawsItems,
                'nmagSorcOrbs': renderNmagSorcOrbsItems,
                'nmagDaggers': renderNmagDaggersItems,
                'nmagBarbarianHelms': renderNmagBarbarianHelmsItems,
                'nmagAmazonSkills': renderNmagAmazonSkillsItems,
                'nmagPaladinSkills': renderNmagPaladinSkillsItems,
                'nmagSorceressSkills': renderNmagSorceressSkillsItems,
                'nmagDruidSkills': renderNmagDruidSkillsItems,
                'nmagBarbarianSkills': renderNmagBarbarianSkillsItems,
                'nmagNecromancerSkills': renderNmagNecromancerSkillsItems,
                'nmagAssassinSkills': renderNmagAssassinSkillsItems,
//                'nmagJavelins': renderNmagJavelinsItems,
                'nmagAmazonWeapons': renderNmagAmazonWeaponsItems,
                'nmagCirclets': renderNmagCircletsItems
            };
            if (renderMap[category]) renderMap[category]();
            generateFilter();
            
            const code = (typeof key === 'string' && key.includes('_')) ? key.split('_')[0] : key;
            if (code) setTimeout(() => highlightItemInOutput(code, 'NMAG'), 100);
        }

        function setAllNmagLevels(category, key, enabled) {
            for (let i = 0; i < 10; i++) {
                filterState[category][key].filterLevels[i] = enabled;
            }
            const renderMap = {
                'nmagPolearms': renderNmagPolearmsItems,
                'nmagSwords': renderNmagSwordsItems,
                'nmagAxes': renderNmagAxesItems,
                'nmagMaces': renderNmagMacesItems,
                'nmagSpears': renderNmagSpearsItems,
                'nmagBows': renderNmagBowsItems,
                'nmagArmor': renderNmagArmorItems,
                'nmagShields': rendernmagShieldsItems,
                'nmagHelms': renderNmagHelmsItems,
                'nmagDruidPelts': renderNmagDruidPeltsItems,
                'nmagNecroHeads': renderNmagNecroHeadsItems,
                'nmagAssassinClaws': renderNmagAssassinClawsItems,
                'nmagSorcOrbs': renderNmagSorcOrbsItems,
                'nmagDaggers': renderNmagDaggersItems,
                'nmagBarbarianHelms': renderNmagBarbarianHelmsItems,
                'nmagAmazonSkills': renderNmagAmazonSkillsItems,
                'nmagPaladinSkills': renderNmagPaladinSkillsItems,
                'nmagSorceressSkills': renderNmagSorceressSkillsItems,
                'nmagDruidSkills': renderNmagDruidSkillsItems,
                'nmagBarbarianSkills': renderNmagBarbarianSkillsItems,
                'nmagNecromancerSkills': renderNmagNecromancerSkillsItems,
                'nmagAssassinSkills': renderNmagAssassinSkillsItems,
//                'nmagJavelins': renderNmagJavelinsItems,
                'nmagAmazonWeapons': renderNmagAmazonWeaponsItems,
            };
            if (renderMap[category]) renderMap[category]();
            generateFilter();
            
            const code = (typeof key === 'string' && key.includes('_')) ? key.split('_')[0] : key;
            if (code) setTimeout(() => highlightItemInOutput(code, 'NMAG'), 100);
        }

        // Preset functions for NMAG items
        // Class skill preset functions
        function applyNmagAmazonSkillsPreset(preset) {
            if (!preset) return;
            nmagAmazonSkills.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'all') {
                    filterState.nmagAmazonSkills[key].show = true;
                } else if (preset === 'none') {
                    filterState.nmagAmazonSkills[key].show = false;
                }
            });
            renderNmagAmazonSkillsItems();
            generateFilter();
        }

        function applyNmagAssassinSkillsPreset(preset) {
            if (!preset) return;
            nmagAssassinSkills.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'all') {
                    filterState.nmagAssassinSkills[key].show = true;
                } else if (preset === 'elite') {
                    filterState.nmagAssassinSkills[key].show = item.quality === 'elite';
                } else if (preset === 'none') {
                    filterState.nmagAssassinSkills[key].show = false;
                }
            });
            renderNmagAssassinSkillsItems();
            generateFilter();
        }

        function applyNmagBarbarianSkillsPreset(preset) {
            if (!preset) return;
            nmagBarbarianSkills.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'all') {
                    filterState.nmagBarbarianSkills[key].show = true;
                } else if (preset === 'elite') {
                    filterState.nmagBarbarianSkills[key].show = item.quality === 'elite';
                } else if (preset === 'none') {
                    filterState.nmagBarbarianSkills[key].show = false;
                }
            });
            renderNmagBarbarianSkillsItems();
            generateFilter();
        }

        function applyNmagDruidSkillsPreset(preset) {
            if (!preset) return;
            nmagDruidSkills.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'all') {
                    filterState.nmagDruidSkills[key].show = true;
                } else if (preset === 'elite') {
                    filterState.nmagDruidSkills[key].show = item.quality === 'elite';
                } else if (preset === 'none') {
                    filterState.nmagDruidSkills[key].show = false;
                }
            });
            renderNmagDruidSkillsItems();
            generateFilter();
        }

        function applyNmagNecromancerSkillsPreset(preset) {
            if (!preset) return;
            nmagNecromancerSkills.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'all') {
                    filterState.nmagNecromancerSkills[key].show = true;
                } else if (preset === 'elite') {
                    filterState.nmagNecromancerSkills[key].show = item.quality === 'elite';
                } else if (preset === 'none') {
                    filterState.nmagNecromancerSkills[key].show = false;
                }
            });
            renderNmagNecromancerSkillsItems();
            generateFilter();
        }

        function applyNmagPaladinSkillsPreset(preset) {
            if (!preset) return;
            nmagPaladinSkills.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'all') {
                    filterState.nmagPaladinSkills[key].show = true;
                } else if (preset === 'elite') {
                    filterState.nmagPaladinSkills[key].show = item.quality === 'elite';
                } else if (preset === 'shields') {
                    // Paladin shields have codes starting with 'pa'
                    filterState.nmagPaladinSkills[key].show = item.code.startsWith('pa');
                } else if (preset === 'scepters') {
                    // Scepters have codes ending with 'sc', 'qs', or 'ws'
                    filterState.nmagPaladinSkills[key].show = item.code.endsWith('sc') || item.code.endsWith('qs') || item.code.endsWith('ws');
                } else if (preset === 'none') {
                    filterState.nmagPaladinSkills[key].show = false;
                }
            });
            renderNmagPaladinSkillsItems();
            generateFilter();
        }

        function applyNmagSorceressSkillsPreset(preset) {
            if (!preset) return;
            nmagSorceressSkills.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'all') {
                    filterState.nmagSorceressSkills[key].show = true;
                } else if (preset === 'elite') {
                    filterState.nmagSorceressSkills[key].show = item.quality === 'elite';
                } else if (preset === 'ignore-2-soc') {
                    filterState.nmagSorceressSkills[key].show = item.max_sockets > 2 ;
                } else if (preset === 'orbs') {
                    // Orbs have codes starting with 'ob'
                    filterState.nmagSorceressSkills[key].show = item.code.startsWith('ob');
                } else if (preset === 'staves') {
                    // Staves have codes containing 'st' or 'ws' or 'cs' or 'bs'
                    const code = item.code;
                    filterState.nmagSorceressSkills[key].show = !code.startsWith('ob');
                } else if (preset === 'none') {
                    filterState.nmagSorceressSkills[key].show = false;
                }
            }); //ignore-2-soc
            renderNmagSorceressSkillsItems();
            generateFilter();
        }

        function applyNmagPolearmsPreset(preset) {
            if (!preset) return;
            nmagPolearms.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagPolearms[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagPolearms[key].show = false;
                } else if (preset === 'elite-only') {
                    filterState.nmagPolearms[key].show = item.quality === 'elite';
                } else if (preset === 'eth-only') {
                    filterState.nmagPolearms[key].show = true;
                    filterState.nmagPolearms[key].ethFilter = 'eth-only';
                } else if (preset === '4sock') {
                    filterState.nmagPolearms[key].show = true;
                    filterState.nmagPolearms[key].sockFilter = '4';
                }
            });
            renderNmagPolearmsItems();
            generateFilter();
        }

        function applyNmagSwordsPreset(preset) {
            if (!preset) return;
            nmagSwords.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagSwords[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagSwords[key].show = false;
                } else if (preset === 'elite-only') {
                    filterState.nmagSwords[key].show = item.quality === 'elite';
                }
            });
            renderNmagSwordsItems();
            generateFilter();
        }

        function applyNmagAxesPreset(preset) {
            if (!preset) return;
            nmagAxes.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagAxes[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagAxes[key].show = false;
                }
            });
            renderNmagAxesItems();
            generateFilter();
        }

        function applyNmagMacesPreset(preset) {
            if (!preset) return;
            nmagMaces.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagMaces[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagMaces[key].show = false;
                }
            });
            renderNmagMacesItems();
            generateFilter();
        }

        function applyNmagBowsPreset(preset) {
            if (!preset) return;
            nmagBows.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagBows[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagBows[key].show = false;
                }
            });
            renderNmagBowsItems();
            generateFilter();
        }

        function applyNmagSpearsPreset(preset) {
            if (!preset) return;
            nmagSpears.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagSpears[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagSpears[key].show = false;
                }
            });
            renderNmagSpearsItems();
            generateFilter();
        }

        function applyNmagArmorPreset(preset) {
            if (!preset) return;
            nmagArmor.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagArmor[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagArmor[key].show = false;
                } else if (preset === 'elite-only') {
                    filterState.nmagArmor[key].show = item.quality === 'elite';
                }
            });
            renderNmagArmorItems();
            generateFilter();
        }

        function applynmagShieldsPreset(preset) {
            if (!preset) return;
            nmagShields.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagShields[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagShields[key].show = false;
                }
            });
            rendernmagShieldsItems();
            generateFilter();
        }

        function applyNmagHelmsPreset(preset) {
            if (!preset) return;
            nmagHelms.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagHelms[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagHelms[key].show = false;
                }
            });
            renderNmagHelmsItems();
            generateFilter();
        }

        function applyNmagDruidPeltsPreset(preset) {
            if (!preset) return;
            nmagDruidPelts.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagDruidPelts[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagDruidPelts[key].show = false;
                }
            });
            renderNmagDruidPeltsItems();
            generateFilter();
        }

        function applyNmagNecroHeadsPreset(preset) {
            if (!preset) return;
            nmagNecroHeads.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagNecroHeads[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagNecroHeads[key].show = false;
                }
            });
            renderNmagNecroHeadsItems();
            generateFilter();
        }

        function applyNmagAssassinClawsPreset(preset) {
            if (!preset) return;
            nmagAssassinClaws.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagAssassinClaws[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagAssassinClaws[key].show = false;
                }
            });
            renderNmagAssassinClawsItems();
            generateFilter();
        }

        function applyNmagSorcOrbsPreset(preset) {
            if (!preset) return;
            nmagSorcOrbs.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagSorcOrbs[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagSorcOrbs[key].show = false;
                }
            });
            renderNmagSorcOrbsItems();
            generateFilter();
        }

        function applyNmagDaggersPreset(preset) {
            if (!preset) return;
            nmagDaggers.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagDaggers[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagDaggers[key].show = false;
                } else if (preset === 'elite-only') {
                    filterState.nmagDaggers[key].show = (item.quality === 'elite');
                }
            });
            renderNmagDaggersItems();
            generateFilter();
        }

        function applyNmagBarbarianHelmsPreset(preset) {
            if (!preset) return;
            nmagBarbarianHelms.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagBarbarianHelms[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagBarbarianHelms[key].show = false;
                } else if (preset === 'elite-only') {
                    filterState.nmagBarbarianHelms[key].show = (item.quality === 'elite');
                }
            });
            renderNmagBarbarianHelmsItems();
            generateFilter();
        }

        function applyNmagJavelinsPreset(preset) {
            if (!preset) return;
            nmagJavelins.forEach((item, idx) => {
                const key = item.code + '_' + idx;
                if (preset === 'show-all') {
                    filterState.nmagJavelins[key].show = true;
                } else if (preset === 'hide-all') {
                    filterState.nmagJavelins[key].show = false;
                }
            });
//            renderNmagJavelinsItems();
            generateFilter();
        }

        // Generate filter output
        // Helper function to add random color codes between characters
        function addRandomColors(text) {
            const colorCodes = ['\u00ffc0', '\u00ffc1', '\u00ffc2', '\u00ffc3', '\u00ffc4', '\u00ffc5', '\u00ffc8', '\u00ffc9'];
            const chars = text.split('');
            const coloredChars = [];
            
            for (let i = 0; i < chars.length; i++) {
                // Randomly decide if we should add a color code (60% chance)
                if (Math.random() > 0.4) {
                    const randomColor = colorCodes[Math.floor(Math.random() * colorCodes.length)];
                    coloredChars.push(randomColor);
                }
                coloredChars.push(chars[i]);
            }
            
            return coloredChars.join('');
        }

        // Generate class-specific skill sections (sorceress, necro, etc)
        // allowedTrees: optional array of tree keys to restrict output (e.g., ['bow', 'javelin'] for Amazon)
        // showResistances: optional boolean to add resistance checks (for Paladin shields)
        function generateClassSkillSection(classKey, itemTypeCodes, itemArray, stateCategory, sectionTitle, allowedTrees = null, showResistances = false) {
            // Check if any items are selected for this class
            const hasSelectedItems = itemArray.some((item, idx) => {
                const key = item.code + '_' + idx;
                return filterState[stateCategory]?.[key]?.show;
            });
            
            // Check if any skills are selected for this class
            const classSkillsData = classSkills[classKey];
            let hasSelectedSkills = false;
            
            if (globalSettings.selectedSkillGroups.includes('ALLSK')) {
                hasSelectedSkills = true;
            }
            
            const classSkillCode = classSkillCodes[classKey];
            if (classSkillCode && globalSettings.selectedSkillGroups.includes(classSkillCode)) {
                hasSelectedSkills = true;
            }
            
            if (classSkillsData) {
                for (const [treeKey, skills] of Object.entries(classSkillsData)) {
                    const treeSkillCode = treeSkillCodes[`${classKey}-${treeKey}`];
                    if (treeSkillCode && globalSettings.selectedSkillGroups.includes(treeSkillCode)) {
                        hasSelectedSkills = true;
                    }
                    
                    skills.forEach(skill => {
                        const isSelected = globalSettings.selectedSkills.some(s => {
                            if (s.type === 'skill') {
                                return s.id === skill.id;
                            } else if (s.type === 'stat' && skill.stat) {
                                return s.stat === skill.stat;
                            }
                            return false;
                        });
                        if (isSelected) {
                            hasSelectedSkills = true;
                        }
                    });
                }
            }
            
//            console.log(`generateClassSkillSection for ${classKey}:`, {
//                hasSelectedItems,
//                hasSelectedSkills,
//                selectedSkills: globalSettings.selectedSkills,
//                selectedSkillGroups: globalSettings.selectedSkillGroups,
//                stateCategory,
//                itemArrayLength: itemArray.length
//            });
            
            // Check if any resistances are selected (for Paladin)
            const hasSelectedResistances = showResistances && 
                (globalSettings.paladinResistances.low || 
                 globalSettings.paladinResistances.mid || 
                 globalSettings.paladinResistances.high);
            
            if (!hasSelectedItems && !hasSelectedSkills && !hasSelectedResistances) {
                return ''; // Skip section if no items AND no skills AND no resistances selected
            }
            
            let lines = `\n// === ${sectionTitle} ===\n`;
            lines += `EnableIf[(NMAG OR CRAFT OR (MAG ID) OR (RARE ID)) ${itemTypeCodes}]\n`;
            
            // Add resistance checks (for Paladin shields) - only add lines that are selected
            if (showResistances) {
                if (globalSettings.paladinResistances.high) {
                    lines += `\tItemDisplay[RES>39]: %NAME% %LIGHT_GRAY% %RES%AllRes %CONTINUE%\n`;
                }
                if (globalSettings.paladinResistances.mid) {
                    lines += `\tItemDisplay[RES>29 AND RES<40]: %NAME% %LIGHT_GRAY% %RES%AllRes %CONTINUE%\n`;
                }
                if (globalSettings.paladinResistances.low) {
                    lines += `\tItemDisplay[RES<30]: %NAME% %LIGHT_GRAY% %RES%AllRes %CONTINUE%\n`;
                }
            }
            
            // Add skill group lines based on what's selected in globalSettings
            if (globalSettings.selectedSkillGroups.includes('ALLSK')) {
                lines += `\tItemDisplay[ALLSK>0]: %NAME% %LIGHT_GRAY%+All Skills%CONTINUE%\n`;
            }
            
            // Add class skill group (e.g., CLSK1 for Sorceress) - reuse classSkillCode from above
            if (classSkillCode && globalSettings.selectedSkillGroups.includes(classSkillCode)) {
                const className = classNames[classKey];
                lines += `\tItemDisplay[${classSkillCode}>0]: %NAME% %LIGHT_GRAY%+${className} Skills%CONTINUE%\n`;
            }
            
            // Add tree skill groups (e.g., TABSK8, TABSK9, TABSK10 for Sorc) - reuse classSkillsData from above
            if (classSkillsData) {
                for (const [treeKey, skills] of Object.entries(classSkillsData)) {
                    // Skip if allowedTrees is specified and this tree is not in the list
                    if (allowedTrees && !allowedTrees.includes(treeKey)) continue;

                    const treeSkillCode = treeSkillCodes[`${classKey}-${treeKey}`];
                    if (treeSkillCode && globalSettings.selectedSkillGroups.includes(treeSkillCode)) {
                        const treeName = treeNames[treeKey];
                        const className = classNames[classKey];
                        // Only split for Amazon Bow & Crossbow and Javelin & Spear
                        if (classKey === 'amazon' && (treeKey === 'bow' || treeKey === 'javelin')) {
                            lines += `\tItemDisplay[${treeSkillCode}=3]: %NAME% %LIGHT_GRAY%+3 ${className} ${treeName} Skills%CONTINUE%\n`;
                            lines += `\tItemDisplay[${treeSkillCode}=2]: %NAME% %LIGHT_GRAY%+2 ${className} ${treeName} Skills%CONTINUE%\n`;
                            lines += `\tItemDisplay[${treeSkillCode}=1]: %NAME% %LIGHT_GRAY%+1 ${className} ${treeName} Skills%CONTINUE%\n`;
                        } else {
                            lines += `\tItemDisplay[${treeSkillCode}>0]: %NAME% %LIGHT_GRAY%+${className} ${treeName} Skills%CONTINUE%\n`;
                        }
                    }
                }
            }
            
            // Add individual skill lines (skip if allowedTrees is specified - only show tree groups)
            if (classSkillsData && !allowedTrees) {
                for (const [treeKey, skills] of Object.entries(classSkillsData)) {
                    skills.forEach(skill => {
                        // Check if this skill is selected
                        const isSelected = globalSettings.selectedSkills.some(s => {
                            if (s.type === 'skill') {
                                return s.id === skill.id;
                            } else if (s.type === 'stat' && skill.stat) {
                                return s.stat === skill.stat;
                            }
                            return false;
                        });
                        
                        if (skill.stat) {
                            // STAT-based skill (like Elemental & Poison)
                            if (isSelected) {
                                lines += `\tItemDisplay[STAT(${skill.stat})>0]: %NAME% %LIGHT_GRAY%+%STAT(${skill.stat})% ${skill.name}% %CONTINUE%\n`;
                            } else {
                                lines += `\tItemDisplay[STAT(${skill.stat})>0]:\n`;
                            }
                        } else {
                            // Regular skill ID
                            if (isSelected) {
                                lines += `\tItemDisplay[SKILL("${skill.name}")>0]: %NAME% %LIGHT_GRAY%+%SKILL(${skill.id})% %SKILLNAME(${skill.id})% %CONTINUE%\n`;
                            } else {
                                lines += `\tItemDisplay[SKILL("${skill.name}")>0]:\n`;
                            }
                        }
                    });
                }
            }
            
            // Add item lines only if specific items are selected
            if (hasSelectedItems) {
                itemArray.forEach((item, idx) => {
                    const key = item.code + '_' + idx;
                    const state = filterState[stateCategory][key];
                    
                    if (state.show) {
                        lines += `\t// ${item.name} (${item.code})\n`;
                        
                        // Generate filter level condition if enabled
                        const filtLvlCondition = generateFilterLevelCondition(state.filterLevels);
                        
                        // Build socket condition
                        let sockCondition = '';
                        if (state.sockFilter && state.sockFilter.length > 0) {
                            if (state.sockFilter.length === 1) {
                                sockCondition = ` SOCK=${state.sockFilter[0]}`;
                            } else {
                                const sockParts = state.sockFilter.map(s => `SOCK=${s}`).join(' OR ');
                                sockCondition = ` (${sockParts})`;
                            }
                        }
                        
                        // Build ED condition
                        let edCondition = '';
                        if (state.edFilter === '15') {
                            edCondition = ' ED=15';
                        } else if (state.edFilter === '14+') {
                            edCondition = ' ED>13';
                        } else if (state.edFilter === '13+') {
                            edCondition = ' ED>12';
                        } else if (state.edFilter === '12+') {
                            edCondition = ' ED>11';
                        } else if (state.edFilter === '10+') {
                            edCondition = ' ED>9';
                        }
                        
                        // Build style reference for border/background/notification
                        let styleRef = '';
                        if (state.useCustomColors || state.chatNotification) {
                            const needsBorder = state.useCustomColors && state.borderColor !== null;
                            const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                            const needsNotification = state.chatNotification;
                            
                            if (needsBorder || needsBackground || needsNotification) {
                                const rgbParts = [];
                                if (needsNotification) {
                                    const notifyColor = state.fontColor || 'WHITE';
                                    rgbParts.push(`NotificationColor = ${notifyColor}`);
                                }
                                if (needsBorder) {
                                    const rgb = hexToRGBSlash(state.borderColor);
                                    rgbParts.push(`BorderColor = RGB(${rgb}), BorderSize = 3`);
                                }
                                if (needsBackground) {
                                    const rgb = hexToRGBSlash(state.backgroundColor);
                                    rgbParts.push(`BackgroundColor = RGB(${rgb})`);
                                }
                                styleRef = ` <:CustomDisplay: ${rgbParts.join(', ')}>`;
                            }
                        }
                        
                        // Determine display name and socket displays
                        const displayName = state.useCustomName && state.customName ? state.customName : '%NAME%';
                        
                        // Socket display for non-ETH items
                        let socketDisplay;
                        if (item.socketTier === 'premium') {
                            socketDisplay = '%!tansocks!%';
                        } else if (item.socketTier === 'standard') {
                            socketDisplay = '%!graysocks!%';
                        } else {
                            socketDisplay = '%!blacksocks!%';
                        }
                        
                        // Socket display for ETH items
                        let ethSocketDisplay;
                        if (item.socketTier === 'premium') {
                            ethSocketDisplay = '%!tansocks!%';
                        } else {
                            ethSocketDisplay = '%!graysocks!%';
                        }
                        
                        // Build display strings
                        let nameAndSockets;
                        if (state.biggerClickbox) {
                            nameAndSockets = `%NL%       ${displayName} ${socketDisplay}       %NL%%NL%`;
                        } else {
                            nameAndSockets = `${displayName} ${socketDisplay}`;
                        }
                        
                        let ethNameAndSockets;
                        if (state.biggerClickbox) {
                            ethNameAndSockets = `%NL%       ${displayName} ${ethSocketDisplay}       %NL%%NL%`;
                        } else {
                            ethNameAndSockets = `${displayName} ${ethSocketDisplay}`;
                        }
                        
                        // Handle ETH filter
                        if (state.ethFilter === 'eth-only') {
                            let line = `\tItemDisplay[${item.code} ETH${sockCondition}${edCondition}${filtLvlCondition}]: %GRAY% ${ethNameAndSockets}${styleRef}`;
                            lines += line + '\n';
                        } else if (state.ethFilter === 'non-eth') {
                            let line = `\tItemDisplay[${item.code} !ETH${sockCondition}${edCondition}${filtLvlCondition}]:`;
                            if (state.useCustomColors && state.fontColor) {
                                line += ` %${state.fontColor}%`;
                            } else {
                                line += ` %WHITE%`;
                            }
                            if (state.biggerClickbox) {
                                line += ` %NL%       ${displayName} ${socketDisplay}       %NL%%NL%${styleRef}`;
                            } else {
                                line += ` ${displayName} ${socketDisplay}${styleRef}`;
                            }
                            lines += line + '\n';
                        } else {
                            // 'both' - generate two lines
                            let ethLine = `\tItemDisplay[${item.code} ETH${sockCondition}${edCondition}${filtLvlCondition}]: %GRAY% ${ethNameAndSockets}${styleRef}`;
                            lines += ethLine + '\n';
                            
                            let nonEthLine = `\tItemDisplay[${item.code}${sockCondition}${edCondition}${filtLvlCondition}]:`;
                            if (state.useCustomColors && state.fontColor) {
                                nonEthLine += ` %${state.fontColor}%`;
                            } else {
                                nonEthLine += ` %WHITE%`;
                            }
                            if (state.biggerClickbox) {
                                nonEthLine += ` %NL%       ${displayName} ${socketDisplay}       %NL%%NL%${styleRef}`;
                            } else {
                                nonEthLine += ` ${displayName} ${socketDisplay}${styleRef}`;
                            }
                            lines += nonEthLine + '\n';
                        }
                    } else {
                        // Hide all versions
                        lines += `\tItemDisplay[${item.code}]:\n`;
                    }
                });
            } else if (hasSelectedSkills || hasSelectedResistances) {
                // If skills/resistances are selected but no specific items, show all items with catch-all
                lines += `\tItemDisplay[]: %NAME%\n`;
            }
            
            // Close the EnableIf block
            lines += `EndIf[]\n`;
            
            return lines;
        }

        function generateFilter() {
            console.log('[generateFilter] Starting filter generation...');
            // Get current date formatted as "DD MMM"
            const now = new Date();
            const day = now.getDate();
            const month = now.toLocaleString('en-US', { month: 'short' });
            const dateStr = `${day} ${month}`;
            
            let filter = '// PoD FilterBuilder Visual Filter Builder\n';
            filter += '// Generated: ' + new Date().toLocaleString() + '\n\n';
            filter += 'Attribute[Author]: You\n';
            filter += 'Attribute[Name]: Filter Builder filter\n';
            filter += `Attribute[Date]: ${dateStr}\n\n`;

            // Add FilterLevel declarations if enabled (only for named levels)
            if (globalSettings.enableFilterLevels) {
                const namedLevels = globalSettings.levelNames
                    .map((name, idx) => ({ name, level: idx + 1 }))
                    .filter(item => item.name);
                
                if (namedLevels.length > 0) {
                    filter += '// === FILTER LEVELS ===\n\n';
                    const surpriseMe = document.getElementById('surprise-me')?.checked || false;
                    namedLevels.forEach(item => {
                        const levelName = surpriseMe ? addRandomColors(item.name) : item.name;
                        filter += `FilterLevel[${item.level}]: ${levelName}\n`;
                    });
                    filter += '\n';
                }
            }

            // Add Text Macros for socket displays
            filter += '// === TEXT MACROS ===\n\n';
            filter += 'TextMacro[tansocks]: %TAN%[%SOCKETS%] // %!tansocks!%\n';
            filter += 'TextMacro[graysocks]: %GRAY%[%SOCKETS%] // %!graysocks!%\n';
            filter += 'TextMacro[blacksocks]: %BLACK%[%SOCKETS%] // %!blacksocks!%\n\n';

            // Check if any items need custom styles (for border/background colors)
            let needsCustomStyle = false;
            
            utilityItems.forEach(item => {
                const state = filterState.utility[item.code];
                if (state.show) {
                    const needsBorder = state.useCustomColors && state.borderColor !== null;
                    const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                    const needsNotification = state.chatNotification;
                    if (needsBorder || needsBackground || needsNotification) {
                        needsCustomStyle = true;
                    }
                }
            });

            runeItems.forEach(item => {
                const state = filterState.runes[item.code];
                if (state.show) {
                    const needsBorder = state.useCustomColors && state.borderColor !== null;
                    const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                    const needsNotification = state.chatNotification;
                    if (needsBorder || needsBackground || needsNotification) {
                        needsCustomStyle = true;
                    }
                }
            });

            gemItems.forEach(item => {
                const state = filterState.gems[item.code];
                if (state.show) {
                    const needsBorder = state.useCustomColors && state.borderColor !== null;
                    const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                    const needsNotification = state.chatNotification;
                    if (needsBorder || needsBackground || needsNotification) {
                        needsCustomStyle = true;
                    }
                }
            });

            miscItems.forEach(item => {
                const state = filterState.misc[item.code];
                if (state.show) {
                    const needsBorder = state.useCustomColors && state.borderColor !== null;
                    const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                    const needsNotification = state.chatNotification;
                    if (needsBorder || needsBackground || needsNotification) {
                        needsCustomStyle = true;
                    }
                }
            });

            // Generate single ItemStyle declaration if needed
            if (needsCustomStyle) {
                filter += '// === CUSTOM STYLE ===\n\n';
                filter += 'ItemStyle[CustomDisplay]: NotificationColor = WHITE\n\n';
            }

            // Filter Start - Moved
//            filter += '// === Default of never hiding runewords or identified items ===\n\n';
//            filter += 'ItemDisplay[RW]: %NAME%\n';
//            filter += 'ItemDisplay[ID]: %NAME%\n\n';

            // --- COMMUNITY MODULES CUSTOM SECTION ---
            let customSectionLines = '';
            if (window.communityModules && filterState.communityModules) {
                Object.entries(window.communityModules).forEach(([moduleName, rules]) => {
                    rules.forEach(rule => {
                        if (filterState.communityModules[moduleName] && filterState.communityModules[moduleName][rule.id]) {
                            // Add each filter line from the rule, substituting custom name if present
                            rule.filterLines.forEach(line => {
                                // Only substitute for ItemDisplay lines
                                let newLine = line;
                                const itemDisplayMatch = line.match(/^(\s*ItemDisplay\[[^\]]*\]:)(.*)$/i);
                                if (itemDisplayMatch) {
                                    // Find custom name for this module/rule
                                    let customName = '';
                                    if (filterState.communityModulesCustomNames && filterState.communityModulesCustomNames[moduleName] && filterState.communityModulesCustomNames[moduleName][rule.id]) {
                                        customName = filterState.communityModulesCustomNames[moduleName][rule.id];
                                    }
                                    if (customName && customName.trim() && customName.trim() !== '%NAME%') {
                                        // Replace the right-hand side with the custom name
                                        newLine = itemDisplayMatch[1] + ' ' + customName.trim();
                                    }
                                }
                                customSectionLines += newLine + '\n';
                            });
                        }
                    });
                });
            }
            if (customSectionLines) {
                filter += '// === CUSTOM (COMMUNITY MODULES) ===\n' + customSectionLines + '\n';
            }

            // Utility items
            filter += '// === UTILITY ITEMS START===\n';
            let scrollLines = ''; // Store scroll lines to add at end
            utilityItems.forEach(item => {
                filter += `// ${item.name} (${item.code})\n`;
                const state = filterState.utility[item.code];
                if (item.code === 'gold') {
                    if (state.show) {
                        filter += 'ItemDisplay[GOLD>2500]: %NAME%\n';
                        filter += 'ItemDisplay[GOLD<100 CLVL<20]:\n';
                        filter += 'ItemDisplay[GOLD<250 (CLVL>19 AND CLVL<=65)]:\n';
                        filter += 'ItemDisplay[GOLD<2500 CLVL>65]:\n';
                    } else {
                        filter += 'ItemDisplay[gold]:\n';
                    }
                    return;
                }
                if (state.show) {
                    // Special handling for scrolls with "only show when low" option
                    if (state.onlyShowWhenLow && (item.code === 'tsc' || item.code === 'isc')) {
                        const threshold = item.code === 'tsc' ? 'TPSCROLLS>15' : 'IDSCROLLS>25';
                        const displayName = state.useCustomName && state.customName ? state.customName : '%NAME%';
                        // Store scroll lines to add at end of filter
                        scrollLines += `ItemDisplay[${item.code} ${threshold}]:\n`;
                        scrollLines += `ItemDisplay[${item.code}]: ${displayName}\n`;
                        return; // Skip normal processing
                    }
                    // Generate filter level condition if enabled
                    const filtLvlCondition = generateFilterLevelCondition(state.filterLevels);
                    let line = `ItemDisplay[${item.code}${filtLvlCondition}]:`;
                    // Only add colors if custom colors are enabled
                    if (state.useCustomColors && state.fontColor !== 'WHITE') {
                        line += ` %${state.fontColor}%`;
                    }
                    const displayName = state.useCustomName && state.customName ? state.customName : '%NAME%';
                    if (state.biggerClickbox) {
                        line += ` %NL%       ${displayName}       %NL%%NL%`;
                    } else {
                        line += ` ${displayName}`;
                    }
                    // Add style reference for border/background/notification if needed
                    if (state.useCustomColors || state.chatNotification) {
                        const needsBorder = state.useCustomColors && state.borderColor !== null;
                        const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                        const needsNotification = state.chatNotification;
                        if (needsBorder || needsBackground || needsNotification) {
                            const rgbParts = [];
                            if (needsNotification) {
                                const notifyColor = state.fontColor || 'WHITE';
                                rgbParts.push(`NotificationColor = ${notifyColor}`);
                            }
                            if (needsBorder) {
                                const rgb = hexToRGBSlash(state.borderColor);
                                rgbParts.push(`BorderColor = RGB(${rgb}), BorderSize = 3`);
                            }
                            if (needsBackground) {
                                const rgb = hexToRGBSlash(state.backgroundColor);
                                rgbParts.push(`BackgroundColor = RGB(${rgb})`);
                            }
                            line += ` <:CustomDisplay: ${rgbParts.join(', ')}>`;
                        }
                    }
                    filter += line + '\n';
                } else {
                    filter += `ItemDisplay[${item.code}]:\n`;
                }
            });
            filter += '// === UTILITY ITEMS STOP===\n\n';

            // Runes
            filter += '\n// === RUNES START===\n';
            runeItems.forEach(item => {
                filter += `// ${item.name} (${item.code})\n`;
                const state = filterState.runes[item.code];
                if (state.show) {
                    // Generate filter level condition if enabled
                    const filtLvlCondition = generateFilterLevelCondition(state.filterLevels);
                    let line = `ItemDisplay[${item.code}${filtLvlCondition}]:`;
                    
                    // Only add colors if custom colors are enabled
                    if (state.useCustomColors && state.fontColor !== 'ORANGE') {
                        line += ` %${state.fontColor}%`;
                    }
                    
                    const displayName = state.useCustomName && state.customName ? state.customName : '%NAME%';
                    if (state.biggerClickbox) {
                        line += ` %NL%       ${displayName}       %NL%%NL%`;
                    } else {
                        line += ` ${displayName}`;
                    }
                    
                    // Add style reference for border/background/notification if needed
                    if (state.useCustomColors || state.chatNotification) {
                        const needsBorder = state.useCustomColors && state.borderColor !== null;
                        const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                        const needsNotification = state.chatNotification;
                        
                        if (needsBorder || needsBackground || needsNotification) {
                            const rgbParts = [];
                            if (needsNotification) {
                                const notifyColor = state.fontColor || 'ORANGE';
                                rgbParts.push(`NotificationColor = ${notifyColor}`);
                            }
                            if (needsBorder) {
                                const rgb = hexToRGBSlash(state.borderColor);
                                rgbParts.push(`BorderColor = RGB(${rgb}), BorderSize = 3`);
                            }
                            if (needsBackground) {
                                const rgb = hexToRGBSlash(state.backgroundColor);
                                rgbParts.push(`BackgroundColor = RGB(${rgb})`);
                            }
                            line += ` <:CustomDisplay: ${rgbParts.join(', ')}>`;
                        }
                    }
                    
                    filter += line + '\n';
                } else {
                    filter += `ItemDisplay[${item.code}]:\n`;
                }
            });
            filter += '\n// === RUNES STOP===\n\n';

            // Gems
            filter += '\n// === GEMS START===\n';
            gemItems.forEach(item => {
                filter += `// ${item.name} (${item.code})\n`;
                const state = filterState.gems[item.code];
                if (state.show) {
                    // Generate filter level condition if enabled
                    const filtLvlCondition = generateFilterLevelCondition(state.filterLevels);
                    let line = `ItemDisplay[${item.code}${filtLvlCondition}]:`;
                    
                    // Only add colors if custom colors are enabled
                    if (state.useCustomColors && state.fontColor !== 'WHITE') {
                        line += ` %${state.fontColor}%`;
                    }
                    
                    const displayName = state.useCustomName && state.customName ? state.customName : '%NAME%';
                    if (state.biggerClickbox) {
                        line += ` %NL%       ${displayName}       %NL%%NL%`;
                    } else {
                        line += ` ${displayName}`;
                    }
                    
                    // Add style reference for border/background/notification if needed
                    if (state.useCustomColors || state.chatNotification) {
                        const needsBorder = state.useCustomColors && state.borderColor !== null;
                        const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                        const needsNotification = state.chatNotification;
                        
                        if (needsBorder || needsBackground || needsNotification) {
                            const rgbParts = [];
                            if (needsNotification) {
                                const notifyColor = state.fontColor || 'WHITE';
                                rgbParts.push(`NotificationColor = ${notifyColor}`);
                            }
                            if (needsBorder) {
                                const rgb = hexToRGBSlash(state.borderColor);
                                rgbParts.push(`BorderColor = RGB(${rgb}), BorderSize = 3`);
                            }
                            if (needsBackground) {
                                const rgb = hexToRGBSlash(state.backgroundColor);
                                rgbParts.push(`BackgroundColor = RGB(${rgb})`);
                            }
                            line += ` <:CustomDisplay: ${rgbParts.join(', ')}>`;
                        }
                    }
                    
                    filter += line + '\n';
                } else {
                    filter += `ItemDisplay[${item.code}]:\n`;
                }
            });
            filter += '\n// === GEMS STOP===\n\n';

            // PoD/Misc Items
            filter += '\n// === POD/Keys/Maps/MISC ITEMS START===\n';
            miscItems.forEach(item => {
                filter += `// ${item.name} (${item.code})\n`;
                // Add special items before QUEST
                if (item.code === 'QUEST') {
                    filter += 'ItemDisplay[hst OR msf]: %TAN%%NAME% {%NAME% %DGREEN%[Circle]                [Circle&Crescent]%NL%[Crescent]             [Triangle]%NL%[Square]     [Arrows]%NL%[Star]%NL%%ORANGE%DURIEL TOMB ORDER:} //%NOTIFY(GOLD)%\n';
                    filter += 'ItemDisplay[box]: %TAN% %NAME% %NL% {Weapons: Ral + Amn + P Amethyst %NL% Armor: Tal + Thul + P Topaz %NL% Helmets: Ral + Thul + P Sapphire %NL% Shields: Tal + Amn + P Ruby %NL% Cube recipies for adding sockets to:}\n';
                }
                
                const state = filterState.misc[item.code];
                if (state.show) {
                    // Generate filter level condition if enabled
                    const filtLvlCondition = generateFilterLevelCondition(state.filterLevels);
                    let line = `ItemDisplay[${item.code}${filtLvlCondition}]:`;
                    
                    // Only add colors if custom colors are enabled
                    if (state.useCustomColors && state.fontColor !== 'WHITE') {
                        line += ` %${state.fontColor}%`;
                    }
                    
                    const displayName = state.useCustomName && state.customName ? state.customName : '%NAME%';
                    if (state.biggerClickbox) {
                        line += ` %NL%       ${displayName}       %NL%%NL%`;
                    } else {
                        line += ` ${displayName}`;
                    }
                    
                    // Add style reference for border/background/notification if needed
                    if (state.useCustomColors || state.chatNotification) {
                        const needsBorder = state.useCustomColors && state.borderColor !== null;
                        const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                        const needsNotification = state.chatNotification;
                        
                        if (needsBorder || needsBackground || needsNotification) {
                            const rgbParts = [];
                            if (needsNotification) {
                                const notifyColor = state.fontColor || 'WHITE';
                                rgbParts.push(`NotificationColor = ${notifyColor}`);
                            }
                            if (needsBorder) {
                                const rgb = hexToRGBSlash(state.borderColor);
                                rgbParts.push(`BorderColor = RGB(${rgb}), BorderSize = 3`);
                            }
                            if (needsBackground) {
                                const rgb = hexToRGBSlash(state.backgroundColor);
                                rgbParts.push(`BackgroundColor = RGB(${rgb})`);
                            }
                            line += ` <:CustomDisplay: ${rgbParts.join(', ')}>`;
                        }
                    }
                    
                    filter += line + '\n';
                } else {
                    filter += `ItemDisplay[${item.code}]:\n`;
                }
            });
            filter += '\n// === POD/Keys/Maps/MISC ITEMS STOP===\n\n';

            // Filter Start
            filter += '\n// === Always show runewords and identified items ===\n';
            filter += 'ItemDisplay[RW]: %NAME%\n';
            filter += 'ItemDisplay[(MAG OR RARE OR SET OR UNI OR CRAFT) ID SOCK=0]: %NAME%\n';
            filter += 'ItemDisplay[(MAG OR RARE OR SET OR UNI OR CRAFT) ID]: %NAME% %!tansocks!%\n\n';

            // === UNIQUE ITEMS ===
//            filter += '\n// === UNIQUE ITEMS START===\n';
            
            // Helper function to generate unique item filter lines
            function generateUniqueItemLines(items, stateCategory, sectionTitle) {
                let lines = `// ${sectionTitle}\n`;
                let hasItems = false;
                
                items.forEach(item => {
//                    line += `// ${item.name} (${item.code})\n`;
                    const key = item.name.replace(/[^a-zA-Z0-9]/g, '_');
                    const state = filterState[stateCategory][key];
                    if (state.show) {
                        hasItems = true;
                        // Generate filter level condition if enabled
                        const filtLvlCondition = generateFilterLevelCondition(state.filterLevels);
                        let line = `// ${item.name} (${item.code})\n ItemDisplay[UNI ${item.code}${filtLvlCondition} !ID]:`;
                        
                        // Only add colors if custom colors are enabled
                        if (state.useCustomColors && state.fontColor !== 'GOLD') {
                            line += ` %${state.fontColor}%`;
                        }
                        
                        const displayName = state.useCustomName && state.customName ? state.customName : '%NAME%';
                        if (state.biggerClickbox) {
                            line += ` %NL%       ${displayName}       %NL%`;
                        } else {
                            line += ` ${displayName}`;
                        }
                        
                        // Add style reference for border/background/notification if needed
                        if (state.useCustomColors || state.chatNotification) {
                            const needsBorder = state.useCustomColors && state.borderColor !== null;
                            const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                            const needsNotification = state.chatNotification;
                            
                            if (needsBorder || needsBackground || needsNotification) {
                                const rgbParts = [];
                                if (needsNotification) {
                                    const notifyColor = state.fontColor || 'GOLD';
                                    rgbParts.push(`NotificationColor = ${notifyColor}`);
                                }
                                if (needsBorder) {
                                    const rgb = hexToRGBSlash(state.borderColor);
                                    rgbParts.push(`BorderColor = RGB(${rgb}), BorderSize = 3`);
                                }
                                if (needsBackground) {
                                    const rgb = hexToRGBSlash(state.backgroundColor);
                                    rgbParts.push(`BackgroundColor = RGB(${rgb})`);
                                }
                                line += ` <:CustomDisplay: ${rgbParts.join(', ')}>`;
                            }
                        }
                        
                        lines += line + '\n';
                    } else {
                        lines += `// ${item.name} (${item.code})\n ItemDisplay[UNI ${item.code}]:\n`;
                    }
                });
                
                return hasItems ? lines + '\n' : '';
            }

            // Helper function to generate set item filter lines (uses SET keyword)
            function generateSetItemLines(items, stateCategory, sectionTitle) {
                let lines = `// ${sectionTitle}\n`;
                let hasItems = false;
                
                items.forEach(item => {
                    const key = item.code + '_' + item.set;
                    const state = filterState[stateCategory][key];
                    if (state.show) {
                        hasItems = true;
                        // Generate filter level condition if enabled
                        const filtLvlCondition = generateFilterLevelCondition(state.filterLevels);
                        let line = `// ${item.name} (${item.code})\n ItemDisplay[SET ${item.code}${filtLvlCondition} !ID]:`;
                        
                        // Only add colors if custom colors are enabled
                        if (state.useCustomColors && state.fontColor !== 'GREEN') {
                            line += ` %${state.fontColor}%`;
                        }
                        
                        const displayName = state.useCustomName && state.customName ? state.customName : '%NAME%';
                        if (state.biggerClickbox) {
                            line += ` %NL%       ${displayName}       %NL%%NL%`;
                        } else {
                            line += ` ${displayName}`;
                        }
                        
                        // Add style reference for border/background/notification if needed
                        if (state.useCustomColors || state.chatNotification) {
                            const needsBorder = state.useCustomColors && state.borderColor !== null;
                            const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                            const needsNotification = state.chatNotification;
                            
                            if (needsBorder || needsBackground || needsNotification) {
                                const rgbParts = [];
                                if (needsNotification) {
                                    const notifyColor = state.fontColor || 'GREEN';
                                    rgbParts.push(`NotificationColor = ${notifyColor}`);
                                }
                                if (needsBorder) {
                                    const rgb = hexToRGBSlash(state.borderColor);
                                    rgbParts.push(`BorderColor = RGB(${rgb}), BorderSize = 3`);
                                }
                                if (needsBackground) {
                                    const rgb = hexToRGBSlash(state.backgroundColor);
                                    rgbParts.push(`BackgroundColor = RGB(${rgb})`);
                                }
                                line += ` <:CustomDisplay: ${rgbParts.join(', ')}>`;
                            }
                        }
                        
                        lines += line + '\n';
                    } else {
                        lines += `// ${item.name} (${item.code})\n ItemDisplay[SET ${item.code}]:\n`;
                    }
                });
                
                return hasItems ? lines + '\n' : '';
            }
            
            function generateMagicRareItemLines(items, stateCategory, sectionTitle, rarity) {
                let lines = `// ${sectionTitle}\n`;
                let hasItems = false;
                
                items.forEach((item, idx) => {
                    const key = item.code + '_' + idx;
                    const state = filterState[stateCategory][key];
                    if (state.show) {
                        hasItems = true;
                        // Generate filter level condition if enabled
                        const filtLvlCondition = generateFilterLevelCondition(state.filterLevels);
                        
                        // Build ILVL condition
                        let ilvlCondition = '';
                        if (item.minIlvl !== undefined && item.maxIlvl !== undefined) {
                            ilvlCondition = ` ILVL>${item.minIlvl} ILVL<${item.maxIlvl}`;
                        } else if (item.minIlvl !== undefined) {
                            ilvlCondition = ` ILVL>${item.minIlvl}`;
                        } else if (item.maxIlvl !== undefined) {
                            ilvlCondition = ` ILVL<${item.maxIlvl}`;
                        }
                        
                        let line = `ItemDisplay[${rarity} ${item.code} !ID${ilvlCondition}${filtLvlCondition}]:`;
                        
                        // Add font color
                        if (state.useCustomColors && state.fontColor) {
                            line += ` %${state.fontColor}%`;
                        } else if (rarity === 'MAG') {
                            line += ` %BLUE%`;
                        } else {
                            line += ` %YELLOW%`;
                        }
                        
                        const displayName = state.useCustomName && state.customName ? state.customName : '%NAME%';
                        if (state.biggerClickbox) {
                            line += ` %NL%       ${displayName}       %NL%%NL%`;
                        } else {
                            line += ` ${displayName}`;
                        }
                        
                        // Add ILVL display for magic jewelry and charms, description for magic crafting only
                        if (stateCategory === 'magicJewelry' || stateCategory === 'magicCharms') {
                            line += ` %WHITE%[%ILVL%]`;
                        } else if (item.desc && stateCategory === 'magicCrafting') {
                            // Use grey color for crafting base description
                            line += ` %GREY%{${item.desc}}`;
                        }
                        
                        // Add style reference for border/background/notification if needed
                        if (state.useCustomColors || state.chatNotification) {
                            const needsBorder = state.useCustomColors && state.borderColor !== null;
                            const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                            const needsNotification = state.chatNotification;
                            
                            if (needsBorder || needsBackground || needsNotification) {
                                const rgbParts = [];
                                if (needsNotification) {
                                    const notifyColor = state.fontColor || (rarity === 'MAG' ? 'BLUE' : 'YELLOW');
                                    rgbParts.push(`NotificationColor = ${notifyColor}`);
                                }
                                if (needsBorder) {
                                    const rgb = hexToRGBSlash(state.borderColor);
                                    rgbParts.push(`BorderColor = RGB(${rgb}), BorderSize = 3`);
                                }
                                if (needsBackground) {
                                    const rgb = hexToRGBSlash(state.backgroundColor);
                                    rgbParts.push(`BackgroundColor = RGB(${rgb})`);
                                }
                                line += ` <:CustomDisplay: ${rgbParts.join(', ')}>`;
                            }
                        }
                        
                        lines += line + '\n';
                    } else {
                        // Build hide condition
                        let ilvlCondition = '';
                        if (item.minIlvl !== undefined && item.maxIlvl !== undefined) {
                            ilvlCondition = ` ILVL>${item.minIlvl} ILVL<${item.maxIlvl}`;
                        } else if (item.minIlvl !== undefined) {
                            ilvlCondition = ` ILVL>${item.minIlvl}`;
                        } else if (item.maxIlvl !== undefined) {
                            ilvlCondition = ` ILVL<${item.maxIlvl}`;
                        }
                        lines += `ItemDisplay[${rarity} ${item.code} !ID${ilvlCondition}]:\n`;
                    }
                });
                
                return hasItems ? lines + '\n' : '';
            }
            
            function generateNmagItemLines(items, stateCategory, sectionTitle) {
                let lines = `\t// ${sectionTitle}\n`;
                let hasItems = false;
                
                items.forEach((item, idx) => {
                    const key = item.code + '_' + idx;
                    const state = filterState[stateCategory][key];
                    lines += `\t// ${item.name} (${item.code})\n`;
                    if (state.show) {
                        hasItems = true;
                        
                        // Add comment with item name and code for debugging
//                        lines += `\t// ${item.name} (${item.code})\n`;
                        
                        // Generate filter level condition if enabled
                        const filtLvlCondition = generateFilterLevelCondition(state.filterLevels);
                        
                        // Build socket condition
                        let sockCondition = '';
                        if (state.sockFilter.length > 0) {
                            if (state.sockFilter.length === 1) {
                                sockCondition = ` SOCK=${state.sockFilter[0]}`;
                            } else {
                                // Multiple socket values: (SOCK=3 OR SOCK=4)
                                const sockParts = state.sockFilter.map(s => `SOCK=${s}`).join(' OR ');
                                sockCondition = ` (${sockParts})`;
                            }
                        }
                        
                        // Build ED condition
                        let edCondition = '';
                        if (state.edFilter === '15') {
                            edCondition = ' ED=15';
                        } else if (state.edFilter === '14+') {
                            edCondition = ' ED>13';
                        } else if (state.edFilter === '13+') {
                            edCondition = ' ED>12';
                        } else if (state.edFilter === '12+') {
                            edCondition = ' ED>11';
                        } else if (state.edFilter === '10+') {
                            edCondition = ' ED>9';
                        }
                        
                        // Build style reference for border/background/notification if needed
                        let styleRef = '';
                        if (state.useCustomColors || state.chatNotification) {
                            const needsBorder = state.useCustomColors && state.borderColor !== null;
                            const needsBackground = state.useCustomColors && state.backgroundColor !== null;
                            const needsNotification = state.chatNotification;
                            
                            if (needsBorder || needsBackground || needsNotification) {
                                const rgbParts = [];
                                if (needsNotification) {
                                    const notifyColor = state.fontColor || 'WHITE';
                                    rgbParts.push(`NotificationColor = ${notifyColor}`);
                                }
                                if (needsBorder) {
                                    const rgb = hexToRGBSlash(state.borderColor);
                                    rgbParts.push(`BorderColor = RGB(${rgb}), BorderSize = 3`);
                                }
                                if (needsBackground) {
                                    const rgb = hexToRGBSlash(state.backgroundColor);
                                    rgbParts.push(`BackgroundColor = RGB(${rgb})`);
                                }
                                styleRef = ` <:CustomDisplay: ${rgbParts.join(', ')}>`;
                            }
                        }
                        
                        // Determine display name and socket displays
                        const displayName = state.useCustomName && state.customName ? state.customName : '%NAME%';
                        
                        // Socket display for non-ETH items: use text macro based on socketTier
                        // 'premium' = tan (someone wants this), 'standard' = grey (meh/common), default = black (junk/early)
                        let socketDisplay;
                        if (item.socketTier === 'premium') {
                            socketDisplay = '%!tansocks!%';
                        } else if (item.socketTier === 'standard') {
                            socketDisplay = '%!graysocks!%';
                        } else {
                            socketDisplay = '%!blacksocks!%';
                        }
                        
                        // Socket display for ETH items: grey by default, tan only if premium
                        let ethSocketDisplay;
                        if (item.socketTier === 'premium') {
                            ethSocketDisplay = '%!tansocks!%';
                        } else {
                            ethSocketDisplay = '%!graysocks!%'; // ETH items default to grey
                        }
                        
                        // Build display string based on bigger clickbox setting
                        let nameAndSockets;
                        if (state.biggerClickbox) {
                            nameAndSockets = `%NL%       ${displayName} ${socketDisplay}       %NL%%NL%`;
                        } else {
                            nameAndSockets = `${displayName} ${socketDisplay}`;
                        }
                        
                        // Build ETH display string
                        let ethNameAndSockets;
                        if (state.biggerClickbox) {
                            ethNameAndSockets = `%NL%       ${displayName} ${ethSocketDisplay}       %NL%%NL%`;
                        } else {
                            ethNameAndSockets = `${displayName} ${ethSocketDisplay}`;
                        }
                        
                        // Handle ETH filter - generate two lines when 'any'
                        if (state.ethFilter === 'eth-only') {
                            // ETH only - gray font for everything
                            let line = `\tItemDisplay[NMAG ${item.code} ETH${sockCondition}${edCondition}${filtLvlCondition}]: %GRAY% ${ethNameAndSockets}${styleRef}`;
                            lines += line + '\n';
                        } else if (state.ethFilter === 'non-eth') {
                            // Non-ETH only - white name, colored sockets (tan/black based on socketTier)
                            let line = `\tItemDisplay[NMAG ${item.code} !ETH${sockCondition}${edCondition}${filtLvlCondition}]:`;
                            if (state.useCustomColors && state.fontColor) {
                                line += ` %${state.fontColor}%`;
                            } else {
                                line += ` %WHITE%`;
                            }
                            if (state.biggerClickbox) {
                                line += ` %NL%       ${displayName} ${socketDisplay}       %NL%%NL%${styleRef}`;
                            } else {
                                line += ` ${displayName} ${socketDisplay}${styleRef}`;
                            }
                            lines += line + '\n';
                        } else {
                            // 'any' - generate two lines: ETH first (gray), then non-ETH (white+colored sockets)
                            // Line 1: ETH - grey sockets by default, tan if premium
                            let ethLine = `\tItemDisplay[NMAG ${item.code} ETH${sockCondition}${edCondition}${filtLvlCondition}]: %GRAY% ${ethNameAndSockets}${styleRef}`;
                            lines += ethLine + '\n';
                            
                            // Line 2: Non-ETH - white name, colored sockets based on socketTier
                            let nonEthLine = `\tItemDisplay[NMAG ${item.code}${sockCondition}${edCondition}${filtLvlCondition}]:`;
                            if (state.useCustomColors && state.fontColor) {
                                nonEthLine += ` %${state.fontColor}%`;
                            } else {
                                nonEthLine += ` %WHITE%`;
                            }
                            if (state.biggerClickbox) {
                                nonEthLine += ` %NL%       ${displayName} ${socketDisplay}       %NL%%NL%${styleRef}`;
                            } else {
                                nonEthLine += ` ${displayName} ${socketDisplay}${styleRef}`;
                            }
                            lines += nonEthLine + '\n';
                        }
                    } else {
                        // Hide - just hide all versions of this item code without conditions
                        lines += `\tItemDisplay[NMAG ${item.code}]:\n`;
                    }
                });
                
                return hasItems ? lines + '\n' : '';
            }
            filter += '\n// === UNIQUE ITEMS START===\n';
            filter += generateUniqueItemLines(jewelryAndCharms, 'jewelryCharms', 'Unique Jewelry & Charms');
            filter += generateUniqueItemLines(classSpecificUniques, 'classUniques', 'Class-Specific Uniques');
            filter += generateUniqueItemLines(eliteUniqueWeapons, 'eliteWeapons', 'Elite Unique Weapons');
            filter += generateUniqueItemLines(eliteUniqueArmor, 'eliteArmor', 'Elite Unique Armor');
            filter += generateUniqueItemLines(exceptionalUniqueWeapons, 'excWeapons', 'Exceptional Unique Weapons');
            filter += generateUniqueItemLines(exceptionalUniqueArmor, 'excArmor', 'Exceptional Unique Armor');
            filter += generateUniqueItemLines(normalUniqueWeapons, 'normWeapons', 'Normal Unique Weapons');
            filter += generateUniqueItemLines(normalUniqueArmor, 'normArmor', 'Normal Unique Armor');
            filter += '\n// === UNIQUE ITEMS STOP===\n\n';

            // === SET ITEMS ===
            filter += '\n// === SET ITEMS START===\n\n';
            filter += generateSetItemLines(highLevelSets, 'highSets', 'High-Level Set Items');
            filter += generateSetItemLines(midLevelSets, 'midSets', 'Mid-Level Set Items');
            filter += generateSetItemLines(lowLevelSets, 'lowSets', 'Low-Level Set Items');
            filter += '\n// === SET ITEMS STOP===\n\n';

            // === MAGIC ITEMS ===
            filter += '\n// === MAGIC ITEMS START===\n';
            filter += generateMagicRareItemLines(magicJewelry, 'magicJewelry', 'Magic Jewelry & Jewels', 'MAG');
            filter += generateMagicRareItemLines(magicCharms, 'magicCharms', 'Magic Charms', 'MAG');
            filter += generateMagicRareItemLines(magicCraftingBases, 'magicCrafting', 'Magic Crafting Bases', 'MAG');
            filter += '\n// === MAGIC ITEMS STOP===\n\n';

            // === RARE ITEMS ===
            filter += '\n// === RARE ITEMS START===\n';
            filter += generateMagicRareItemLines(rareJewelry, 'rareJewelry', 'Rare Jewelry & Jewels', 'RARE');
            filter += generateMagicRareItemLines(rareClassItems, 'rareClassItems', 'Rare Class-Specific Items', 'RARE');
            filter += generateMagicRareItemLines(rareEliteBases, 'rareEliteBases', 'Rare Elite Bases', 'RARE');
            filter += '\n// === RARE ITEMS STOP===\n\n';

            // === Defauls "show runewords and identified items" section moved to above uniques ===
//            filter += '\n// === Always show runewords and identified items ===\n';
//            filter += 'ItemDisplay[RW]: %NAME%\n';
//            filter += 'ItemDisplay[(MAG OR RARE OR SET OR UNI OR CRAFT) ID SOCK=0]: %NAME%\n';
//            filter += 'ItemDisplay[(MAG OR RARE OR SET OR UNI OR CRAFT) ID]: %NAME% %!tansocks!%\n\n';

            // === CLASS-SPECIFIC SKILL SECTIONS ===
            // Amazon (spears, javelins, bows - only showing Bow & Crossbow + Javelin & Spear trees)
            filter += generateClassSkillSection('amazon', 'CL7', nmagAmazonSkills, 'nmagAmazonSkills', 'AMAZON: Spears, Javelins & Bows with +Skills', ['bow', 'javelin']);
            
            // Paladin (shields and scepters - includes resistance checks)
            filter += generateClassSkillSection('paladin', '(CL3 OR WP14)', nmagPaladinSkills, 'nmagPaladinSkills', 'PALADIN: Shields & Scepters with +Skills', null, true);
            
            // Sorceress (orbs and staves)
            filter += generateClassSkillSection('sorceress', '(CL6 OR WP11)', nmagSorceressSkills, 'nmagSorceressSkills', 'SORCERESS: Orbs & Staves with +Skills');
            
            // Druid (pelts)
            filter += generateClassSkillSection('druid', 'CL1', nmagDruidSkills, 'nmagDruidSkills', 'DRUID: Pelts with +Skills');
            
            // Barbarian (helms)
            filter += generateClassSkillSection('barbarian', 'CL2', nmagBarbarianSkills, 'nmagBarbarianSkills', 'BARBARIAN: Helms with +Skills');
            
            // Necromancer (shrunken heads and wands)
            filter += generateClassSkillSection('necromancer', '(CL4 OR WP12)', nmagNecromancerSkills, 'nmagNecromancerSkills', 'NECROMANCER: Shrunken Heads & Wands with +Skills');
            
            // Assassin (claws)
            filter += generateClassSkillSection('assassin', 'CL5', nmagAssassinSkills, 'nmagAssassinSkills', 'ASSASSIN: Claws with +Skills');

            // === HIDE JUNK ITEMS SECTION ===
            if (globalSettings.hideJunk) {
                filter += '\n// Hide junk items\n';
                filter += 'ItemDisplay[(ARMOR OR WEAPON) INF]:\n\n';
            }

            // === NMAG RUNEWORD BASES ===
            filter += '\n// === NMAG RUNEWORD BASES START===\n';
            filter += 'EnableIf[NMAG]\n\n';
            filter += generateNmagItemLines(nmagPolearms, 'nmagPolearms', 'NMAG: Polearms (Insight, Infinity, Obedience)');
            filter += generateNmagItemLines(nmagSwords, 'nmagSwords', 'NMAG: Swords (Spirit, Grief)');
            filter += generateNmagItemLines(nmagAxes, 'nmagAxes', 'NMAG: Axes (Grief, Beast, Death)');
            filter += generateNmagItemLines(nmagMaces, 'nmagMaces', 'NMAG: Maces (BoTD, Heart of the Oak)');
            filter += generateNmagItemLines(nmagSpears, 'nmagSpears', 'NMAG: Spears (Infinity, Insight, Pride, Obedience)');
            filter += generateNmagItemLines(nmagBows, 'nmagBows', 'NMAG: Bows (Faith, Ice, Brand, Insight)');
            filter += generateNmagItemLines(nmagArmor, 'nmagArmor', 'NMAG: Armor (Enigma, Fortitude, CoH, Bramble)');
            filter += generateNmagItemLines(nmagShields, 'nmagShields', 'NMAG: Shields - Generic (Spirit, Dream, Splendor)');
            filter += generateNmagItemLines(nmagHelms, 'nmagHelms', 'NMAG: Helms (Delirium, Dream)');
            filter += generateNmagItemLines(nmagDruidPelts, 'nmagDruidPelts', 'NMAG: Druid Pelts (Delirium, Metamorphosis)');
            filter += generateNmagItemLines(nmagNecroHeads, 'nmagNecroHeads', 'NMAG: Necro Shrunken Heads (Splendor, Rhyme)');
            filter += generateNmagItemLines(nmagAssassinClaws, 'nmagAssassinClaws', 'NMAG: Assassin Claws (Chaos, Fury, Plague)');
            filter += generateNmagItemLines(nmagSorcOrbs, 'nmagSorcOrbs', 'NMAG: Sorc Orbs (Plague)');
            filter += generateNmagItemLines(nmagDaggers, 'nmagDaggers', 'NMAG: Daggers');
            filter += generateNmagItemLines(nmagBarbarianHelms, 'nmagBarbarianHelms', 'NMAG: Barbarian Helms (Delirium, Dream)');
//            filter += '\n// ===== Other NMAG base items to follow =====\n\n';
//            filter += generateNmagItemLines(nmagJavelins, 'nmagJavelins', 'NMAG Extended: Javelins');
            // Close NMAG block
            filter += '\n\tItemDisplay[]: %NAME%\n';
            filter += 'EndIf[]\n';
            filter += '\n// === NMAG RUNEWORD BASES STOP===\n';

            // === FILTER CLOSING ===
            
            // Add scroll lines right before "show all" to avoid performance issues
            if (scrollLines) {
                filter += '\n// === SCROLLS (Low Stock Only) ===\n';
                filter += scrollLines;
            }
            
            if (globalSettings.showAll) {
                // === SHOW ALL REMAINING ITEMS, catch all failsafe ===
                filter += '\n// Show all remaining items\n';
                filter += 'ItemDisplay[]: %NAME%\n';
            }

            // WARNING: This function always regenerates and overwrites the filter-output textarea,
            // so any manual or imported lines (such as //COMMUNITY_MODULES) will be lost unless
            // they are handled in the generation logic itself.
            console.log('[generateFilter] Filter length:', filter.length, 'chars');
            console.log('[generateFilter] Updating DOM element...');
            document.getElementById('filter-output').value = filter;
            console.log('[generateFilter] DOM updated successfully');
            updateOutputStats();
        }

        // Helper function to generate FILTLVL condition from filterLevels array
        function generateFilterLevelCondition(filterLevels) {
            if (!globalSettings.enableFilterLevels) return '';

            // Only consider named filter levels
            const namedLevels = globalSettings.levelNames
                .map((name, idx) => name ? idx + 1 : null)
                .filter(l => l !== null);
            const enabledLevels = filterLevels
                .map((enabled, idx) => (enabled && globalSettings.levelNames[idx]) ? idx + 1 : null)
                .filter(l => l !== null);

            if (enabledLevels.length === namedLevels.length) return ''; // All named levels enabled
            if (enabledLevels.length === 0) return ''; // None enabled

            // Check if it's a continuous range within named levels
            const namedEnabledLevels = namedLevels.filter(lvl => enabledLevels.includes(lvl));
            const minLevel = Math.min(...namedEnabledLevels);
            const maxLevel = Math.max(...namedEnabledLevels);
            const isContinuous = namedEnabledLevels.length === (maxLevel - minLevel + 1);

            if (isContinuous) {
                if (minLevel === maxLevel) {
                    return ` FILTERLVL=${minLevel}`;
                } else if (minLevel === Math.min(...namedLevels)) {
                    return ` FILTERLVL<${maxLevel + 1}`;
                } else if (maxLevel === Math.max(...namedLevels)) {
                    return ` FILTERLVL>${minLevel - 1}`;
                } else {
                    return ` (FILTERLVL>${minLevel - 1} AND FILTERLVL<${maxLevel + 1})`;
                }
            }

            // For non-continuous, output only exact matches
            return ' ' + namedEnabledLevels.map(lvl => `FILTERLVL=${lvl}`).join(' OR ');
        }

        // Convert hex color to RGB format for filter
        function hexToRGB(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `${r} ${g} ${b}`;
        }

        // Convert hex color to RGB(r/g/b) format for ItemStyle
        function hexToRGBSlash(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `${r}/${g}/${b}`;
        }

        // Update output statistics
        function updateOutputStats() {
            const output = document.getElementById('filter-output').value;
            const lines = output.split('\n').length;
            const chars = output.length;
            document.getElementById('line-count').textContent = lines;
            document.getElementById('char-count').textContent = chars;
        }

        // Highlight and scroll to item in output
        function highlightItemInOutput(itemCode, prefix = null) {
            const textarea = document.getElementById('filter-output');
            const text = textarea.value;
            
            // Build pattern based on whether we have a prefix
            let pattern;
            if (prefix) {
                // Search for specific prefixed item: ItemDisplay[NMAG 7s8]:
                pattern = new RegExp(`ItemDisplay\\[${prefix} ${itemCode}[^\\]]*\\]:`, 'i');
            } else {
                // Search for simple item: ItemDisplay[r01]:
                pattern = new RegExp(`ItemDisplay\\[${itemCode}[^\\]]*\\]:`, 'i');
            }
            
            const match = text.match(pattern);
            
            if (match) {
                const startPos = match.index;
                const endPos = startPos + match[0].length;
                
                // Use setSelectionRange to automatically scroll into view
                textarea.focus();
                textarea.setSelectionRange(startPos, endPos);
                
                // Add highlight effect
                textarea.classList.add('highlight-active');
                
                // Remove selection and highlight after a moment
                setTimeout(() => {
                    textarea.setSelectionRange(endPos, endPos); // Move cursor to end, removing selection
                    textarea.blur(); // Remove focus
                }, 300);
                
                setTimeout(() => {
                    textarea.classList.remove('highlight-active');
                }, 1000);
            }
        }

        // Modal Management Functions
        let currentModalItem = null;

        function openItemSettings(category, itemKey, itemName, itemType = 'unique') {
            currentModalItem = { category, itemKey, itemType };
            
            const modal = document.getElementById('itemSettingsModal');
            const modalTitle = document.getElementById('modalItemName');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = itemName;
            
            // Populate modal with appropriate controls
            modalBody.innerHTML = generateModalContent(category, itemKey, itemType);
            
            modal.classList.add('show');
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }

        function closeItemSettings(event) {
            // Only close if clicking overlay or close button
            if (event && event.target.closest('.modal-container') && !event.target.classList.contains('modal-close')) {
                return;
            }
            
            const modal = document.getElementById('itemSettingsModal');
            modal.classList.remove('show');
            document.body.style.overflow = ''; // Restore scrolling
            currentModalItem = null;
        }

        // Group Settings Functions
        function openGroupSettings(category, categoryDisplayName) {
            const modal = document.getElementById('itemSettingsModal');
            const modalTitle = document.getElementById('modalItemName');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = `Group Settings: ${categoryDisplayName}`;
            
            // Generate group settings modal content
            modalBody.innerHTML = generateGroupSettingsContent(category);
            
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
            
            // Store current group for apply function
            currentModalItem = { isGroup: true, category };
        }

        function generateGroupSettingsContent(category) {
            let html = '';
            
            // Filter Levels Section
            html += '<div class="modal-section">';
            html += '<h4 class="modal-section-title">Filter Levels (Apply to All Items)</h4>';
            html += '<p style="color: #888; font-size: 12px; margin-bottom: 10px;">Select which filter levels to enable for all items in this group:</p>';
            html += '<div class="modal-control-group">';
            html += '<div class="modal-checkbox-grid">';
            // Only show checkboxes for defined filter levels
            for (let i = 1; i <= 10; i++) {
                if (globalSettings.levelNames[i - 1]) {
                    html += `
                        <label class="modal-checkbox-label">
                            <input type="checkbox" id="group-level-${i}">
                            <span>${i}</span>
                        </label>
                    `;
                }
            }
            html += '</div>';
            html += '<div style="margin-top: 10px;">';
            html += '<button class="modal-btn" onclick="setAllGroupLevels(true)">Select All</button>';
            html += '<button class="modal-btn" onclick="setAllGroupLevels(false)">Clear All</button>';
            html += '</div>';
            html += '</div>';
            html += '</div>';

            // Custom Colors Section
            html += '<div class="modal-section">';
            html += '<h4 class="modal-section-title">Custom Colors</h4>';
            html += '<div class="modal-control-group">';
            html += `
                <label class="modal-checkbox-label">
                    <input type="checkbox" id="group-custom-colors" onchange="toggleGroupCustomColors(this.checked)">
                    <span>Enable Custom Colors for All Items</span>
                </label>
            `;
            html += '<div id="group-color-controls" style="display: none; margin-top: 10px;">';
            
            // Font Color
            html += '<div class="modal-color-row">';
            html += '<span class="modal-color-label">Font Color:</span>';
            html += '<select class="modal-select" id="group-font-color">';
//            html += '<option value="">Default</option>';
            FONT_COLORS.forEach(fc => {
                html += `<option value="${fc}">${fc}</option>`;
            });
            html += '</select>';
            html += '</div>';

            // Border Color
            html += '<div class="modal-color-row">';
            html += '<span class="modal-color-label">Border Color:</span>';
            html += '<input type="color" class="modal-color-input" id="group-border-color" value="#ffffff">';
            html += '</div>';

            // Background Color
            html += '<div class="modal-color-row">';
            html += '<span class="modal-color-label">Background Color:</span>';
            html += '<input type="color" class="modal-color-input" id="group-bg-color" value="#000000">';
            html += '</div>';
            
            html += '</div>';
            html += '</div>';
            html += '</div>';

            // Notifications Section
            html += '<div class="modal-section">';
            html += '<h4 class="modal-section-title">Notifications</h4>';
            html += '<div class="modal-control-group">';
            html += `
                <label class="modal-checkbox-label">
                    <input type="checkbox" id="group-notifications">
                    <span>Enable chat notifications for all items in this group</span>
                </label>
            `;
            html += '</div>';
            html += '</div>';

            // ILVL Setting for Magic Crafting Bases
            if (category === 'magic-crafting') {
                html += '<div class="modal-section">';
                html += '<h4 class="modal-section-title">Item Level Requirement</h4>';
                html += '<div class="modal-control-group">';
                html += '<label style="display: block; margin-bottom: 8px;">Minimum ILVL for crafting bases:</label>';
                html += '<input type="number" id="group-crafting-ilvl" min="1" max="99" value="85" style="width: 80px; padding: 6px; border: 1px solid #555; background: #1a1a1a; color: #fff; border-radius: 4px;">';
                html += '<p style="color: #888; font-size: 12px; margin-top: 8px;">This will update the ILVL requirement for all crafting base items.</p>';
                html += '</div>';
                html += '</div>';
            }

            // Display Options Section
            html += '<div class="modal-section">';
            html += '<h4 class="modal-section-title">Display Options</h4>';
            html += '<div class="modal-control-group">';
            html += `
                <label class="modal-checkbox-label">
                    <input type="checkbox" id="group-bigger-clickbox">
                    <span>Bigger clickbox for all items in this group</span>
                </label>
            `;
            html += '</div>';
            html += '</div>';

            // Apply Button
            html += '<div class="modal-section">';
            html += '<button class="modal-btn modal-btn-primary" onclick="applyGroupSettings()" style="width: 100%; padding: 12px; font-size: 14px; font-weight: bold;">Apply to All Items in Group</button>';
            html += '</div>';

            return html;
        }

        function setAllGroupLevels(checked) {
            for (let i = 1; i <= 10; i++) {
                const checkbox = document.getElementById(`group-level-${i}`);
                if (checkbox) checkbox.checked = checked;
            }
        }

        function toggleGroupCustomColors(enabled) {
            const controls = document.getElementById('group-color-controls');
            if (controls) {
                controls.style.display = enabled ? 'block' : 'none';
            }
        }

        function applyGroupSettings() {
            if (!currentModalItem || !currentModalItem.isGroup) return;
            
            const category = currentModalItem.category;
            
            // Map kebab-case category names to camelCase filterState keys
            const categoryMap = {
                'utility': 'utility',
                'runes': 'runes',
                'gems': 'gems',
                'misc': 'misc',
                'jewelry-charms': 'jewelryCharms',
                'class-uniques': 'classUniques',
                'elite-weapons': 'eliteWeapons',
                'elite-armor': 'eliteArmor',
                'exc-weapons': 'excWeapons',
                'exc-armor': 'excArmor',
                'norm-weapons': 'normWeapons',
                'norm-armor': 'normArmor',
                'high-sets': 'highSets',
                'mid-sets': 'midSets',
                'low-sets': 'lowSets',
                'magic-jewelry': 'magicJewelry',
                'magic-charms': 'magicCharms',
                'magic-crafting': 'magicCrafting',
                'rare-jewelry': 'rareJewelry',
                'rare-class-items': 'rareClassItems',
                'rare-elite-bases': 'rareEliteBases',
                'nmag-polearms': 'nmagPolearms',
                'nmag-swords': 'nmagSwords',
                'nmag-axes': 'nmagAxes',
                'nmag-maces': 'nmagMaces',
                'nmag-spears': 'nmagSpears',
                'nmag-bows': 'nmagBows',
                'nmag-armor': 'nmagArmor',
                'nmag-shields-generic': 'nmagShields',
                'nmag-helms': 'nmagHelms',
                'nmag-druid-pelts': 'nmagDruidPelts',
                'nmag-necro-heads': 'nmagNecroHeads',
                'nmag-assassin-claws': 'nmagAssassinClaws',
                'nmag-sorc-orbs': 'nmagSorcOrbs',
                'nmag-daggers': 'nmagDaggers',
                'nmag-barbarian-helms': 'nmagBarbarianHelms',
                'nmag-javelins': 'nmagJavelins',
                'nmag-amazon-weapons': 'nmagAmazonWeapons',
            };
            
            const stateCategory = categoryMap[category] || category;
            
            // Get selected filter levels
            const selectedLevels = [];
            let anyLevelSelected = false;
            for (let i = 0; i < 10; i++) {
                const checkbox = document.getElementById(`group-level-${i + 1}`);
                if (checkbox && checkbox.checked) {
                    selectedLevels[i] = true;
                    anyLevelSelected = true;
                } else {
                    selectedLevels[i] = false;
                }
            }
            
            // Get color settings
            const useCustomColors = document.getElementById('group-custom-colors')?.checked || false;
            const fontColor = document.getElementById('group-font-color')?.value || '';
            const borderColor = document.getElementById('group-border-color')?.value || '#ffffff';
            const bgColor = document.getElementById('group-bg-color')?.value || '#000000';
            
            // Get notification and clickbox settings
            const chatNotification = document.getElementById('group-notifications')?.checked || false;
            const biggerClickbox = document.getElementById('group-bigger-clickbox')?.checked || false;
            
            // Get crafting base ILVL setting
            let craftingIlvl = null;
            if (category === 'magic-crafting') {
                const ilvlInput = document.getElementById('group-crafting-ilvl');
                if (ilvlInput) {
                    craftingIlvl = parseInt(ilvlInput.value) || 85;
                }
            }
            
            // Apply to all items in the category
            if (!filterState[stateCategory]) filterState[stateCategory] = {};
            
            // Get all items in this category
            let itemsToUpdate = [];
            
            // Determine item list based on category
            if (category === 'utility') itemsToUpdate = utilityItems;
            else if (category === 'runes') itemsToUpdate = runeItems;
            else if (category === 'gems') itemsToUpdate = gemItems;
            else if (category === 'misc') itemsToUpdate = miscItems;
            else if (category === 'jewelry-charms') itemsToUpdate = jewelryAndCharms;
            else if (category === 'class-uniques') itemsToUpdate = classSpecificUniques;
            else if (category === 'elite-weapons') itemsToUpdate = eliteUniqueWeapons;
            else if (category === 'elite-armor') itemsToUpdate = eliteUniqueArmor;
            else if (category === 'exc-weapons') itemsToUpdate = exceptionalUniqueWeapons;
            else if (category === 'exc-armor') itemsToUpdate = exceptionalUniqueArmor;
            else if (category === 'norm-weapons') itemsToUpdate = normalUniqueWeapons;
            else if (category === 'norm-armor') itemsToUpdate = normalUniqueArmor;
            else if (category === 'high-sets') itemsToUpdate = highLevelSets;
            else if (category === 'mid-sets') itemsToUpdate = midLevelSets;
            else if (category === 'low-sets') itemsToUpdate = lowLevelSets;
            else if (category === 'magic-jewelry') itemsToUpdate = magicJewelry;
            else if (category === 'magic-charms') itemsToUpdate = magicCharms;
            else if (category === 'magic-crafting') itemsToUpdate = magicCraftingBases;
            else if (category === 'rare-jewelry') itemsToUpdate = rareJewelry;
            else if (category === 'rare-class-items') itemsToUpdate = rareClassItems;
            else if (category === 'rare-elite-bases') itemsToUpdate = rareEliteBases;
            else if (category.startsWith('nmag-')) {
                // Handle NMAG categories
                const nmagCategories = {
                    'nmag-polearms': nmagPolearms,
                    'nmag-swords': nmagSwords,
                    'nmag-axes': nmagAxes,
                    'nmag-maces': nmagMaces,
                    'nmag-spears': nmagSpears,
                    'nmag-bows': nmagBows,
                    'nmag-armor': nmagArmor,
                    'nmag-shields-generic': nmagShields,
                   'nmag-helms': nmagHelms,
                    'nmag-druid-pelts': nmagDruidPelts,
                    'nmag-necro-heads': nmagNecroHeads,
                    'nmag-assassin-claws': nmagAssassinClaws,
                    'nmag-sorc-orbs': nmagSorcOrbs,
                    'nmag-daggers': nmagDaggers,
                    'nmag-barbarian-helms': nmagBarbarianHelms,
                    'nmag-javelins': nmagJavelins,
                    'nmag-amazon-weapons': nmagAmazonWeapons,
                };
                itemsToUpdate = nmagCategories[category] || [];
            }
            
            // Apply settings to each item
            let successCount = 0;
            itemsToUpdate.forEach((item, idx) => {
                // Determine item key based on category type
                let itemKey;
                
                // Simple items (utility, runes, gems, misc) use code directly
                if (category === 'utility' || category === 'runes' || category === 'gems' || category === 'misc') {
                    itemKey = item.code;
                }
                // Set items use code_set format
                else if (category.includes('-sets')) {
                    itemKey = item.code + '_' + item.set;
                }
                // Magic, rare, and nmag items use code_index format
                else if (category.startsWith('magic-') || category.startsWith('rare-') || category.startsWith('nmag-')) {
                    itemKey = item.code + '_' + idx;
                }
                // Unique items use transformed name
                else if (item.name) {
                    itemKey = item.name.replace(/[^a-zA-Z0-9]/g, '_');
                }
                // Fallback
                else {
                    itemKey = item.code || item.key;
                }
                
                if (!filterState[stateCategory][itemKey]) {
                    filterState[stateCategory][itemKey] = { show: true };
                }
                
                // Only apply group settings to items that are currently shown
                if (!filterState[stateCategory][itemKey].show) {
                    return;
                }
                
                // Apply filter levels if any selected
                if (anyLevelSelected) {
                    filterState[stateCategory][itemKey].filterLevels = [...selectedLevels];
                }
                
                // Apply custom colors
                if (useCustomColors) {
                    filterState[stateCategory][itemKey].useCustomColors = true;
                    if (fontColor) filterState[stateCategory][itemKey].fontColor = fontColor;
                    filterState[stateCategory][itemKey].borderColor = borderColor;
                    filterState[stateCategory][itemKey].backgroundColor = bgColor;
                } else {
                    // Remove custom colors if unchecked
                    filterState[stateCategory][itemKey].useCustomColors = false;
                    delete filterState[stateCategory][itemKey].fontColor;
                    delete filterState[stateCategory][itemKey].borderColor;
                    delete filterState[stateCategory][itemKey].backgroundColor;
                }
                
                // Apply notification
                if (chatNotification) {
                    filterState[stateCategory][itemKey].chatNotification = true;
                } else {
                    // Remove notification if unchecked
                    filterState[stateCategory][itemKey].chatNotification = false;
                }
                
                // Apply bigger clickbox
                if (biggerClickbox) {
                    filterState[stateCategory][itemKey].biggerClickbox = true;
                } else {
                    // Remove bigger clickbox if unchecked
                    filterState[stateCategory][itemKey].biggerClickbox = false;
                }
                
                // Apply crafting ILVL change
                if (craftingIlvl !== null && category === 'magic-crafting') {
                    // Update the item's minIlvl
                    item.minIlvl = craftingIlvl;
                    // Also update the item name to reflect the new ILVL
                    const baseName = item.name.replace(/\(ILVL \d+\+\)/, '').trim();
                    item.name = `${baseName} (ILVL ${craftingIlvl}+)`;
                }
            });
            
            // Regenerate filter and close modal
            generateFilter();
            closeItemSettings();
            
            // Re-render the category to update button states
            const renderFunctions = {
                'utility': renderUtilityItems,
                'runes': renderRuneItems,
                'gems': renderGemsItems,
                'misc': renderMiscItems,
                'jewelryCharms': renderJewelryCharmsItems,
                'classUniques': renderClassUniquesItems,
                'eliteWeapons': renderEliteWeaponsItems,
                'eliteArmor': renderEliteArmorItems,
                'excWeapons': renderExcWeaponsItems,
                'excArmor': renderExcArmorItems,
                'normWeapons': renderNormWeaponsItems,
                'normArmor': renderNormArmorItems,
                'highSets': renderHighSetsItems,
                'midSets': renderMidSetsItems,
                'lowSets': renderLowSetsItems,
                'magicJewelry': renderMagicJewelryItems,
                'magicCharms': renderMagicCharmsItems,
                'magicCrafting': renderMagicCraftingItems,
                'rareJewelry': renderRareJewelryItems,
                'rareClassItems': renderRareClassItemsItems,
                'rareEliteBases': renderRareEliteBasesItems,
                'nmagPolearms': renderNmagPolearmsItems,
                'nmagSwords': renderNmagSwordsItems,
                'nmagAxes': renderNmagAxesItems,
                'nmagMaces': renderNmagMacesItems,
                'nmagSpears': renderNmagSpearsItems,
                'nmagBows': renderNmagBowsItems,
                'nmagArmor': renderNmagArmorItems,
                'nmagShields': rendernmagShieldsItems,
                'nmagHelms': renderNmagHelmsItems,
                'nmagDruidPelts': renderNmagDruidPeltsItems,
                'nmagNecroHeads': renderNmagNecroHeadsItems,
                'nmagAssassinClaws': renderNmagAssassinClawsItems,
                'nmagSorcOrbs': renderNmagSorcOrbsItems,
//                'nmagJavelins': renderNmagJavelinsItems,
                'nmagAmazonWeapons': renderNmagAmazonWeaponsItems,
            };
            
            const renderFunc = renderFunctions[stateCategory];
            if (renderFunc) {
                renderFunc();
            }
            
            // Show success message
            alert(`Group settings applied to ${itemsToUpdate.length} items!`);
        }

        function generateModalContent(category, itemKey, itemType) {
            const state = filterState[category]?.[itemKey] || {};
            let html = '';

            // NMAG-specific controls
            if (itemType === 'nmag') {
                // Eth Filter
                html += '<div class="modal-section">';
                html += '<h4 class="modal-section-title">Ethereal Filter</h4>';
                html += '<div class="modal-control-group">';
                html += '<select class="modal-select" onchange="updateModalEthFilter(\'' + category + '\', \'' + itemKey + '\', this.value)">';
                const ethFilter = state.ethFilter || 'both';
                html += '<option value="both"' + (ethFilter === 'both' ? ' selected' : '') + '>Both Eth and Non-Eth</option>';
                html += '<option value="eth-only"' + (ethFilter === 'eth-only' ? ' selected' : '') + '>Ethereal Only</option>';
                html += '<option value="non-eth"' + (ethFilter === 'non-eth' ? ' selected' : '') + '>Non-Ethereal Only</option>';
                html += '</select>';
                html += '</div>';
                html += '</div>';

                // Socket Filter
                html += '<div class="modal-section">';
                html += '<h4 class="modal-section-title">Sockets</h4>';
                html += '<div class="socket-checkbox-container">';
                const sockFilter = state.sockFilter || [];
                
                // Get max sockets from state (stored from item array)
                const maxSockets = state.max_sockets || 6;
                
                ['0', '2', '3', '4', '5', '6'].filter(sock => parseInt(sock) <= maxSockets).forEach(sock => {
                    const checked = sockFilter.includes(sock) ? 'checked' : '';
                    const label = sock === '0' ? '0 Sockets' : `${sock} Socket${parseInt(sock) > 1 ? 's' : ''}`;
                    html += `
                        <label class="socket-checkbox-label">
                            <input type="checkbox" ${checked} 
                                onchange="updateModalSocket('${category}', '${itemKey}', '${sock}', this.checked)">
                            <span>${label}</span>
                        </label>
                    `;
                });
                html += '</div>';
                html += '</div>';

                // ED Filter
                html += '<div class="modal-section">';
                html += '<h4 class="modal-section-title">Enhanced Damage</h4>';
                html += '<div class="modal-control-group">';
                html += '<select class="modal-select" onchange="updateModalEDFilter(\'' + category + '\', \'' + itemKey + '\', this.value)">';
                const edFilter = state.edFilter || 'any';
                html += '<option value="any"' + (edFilter === 'any' ? ' selected' : '') + '>Any ED</option>';
                html += '<option value="10+"' + (edFilter === '10+' ? ' selected' : '') + '>10% ED or higher</option>';
                html += '<option value="12+"' + (edFilter === '12+' ? ' selected' : '') + '>12% ED or higher</option>';
                html += '<option value="13+"' + (edFilter === '13+' ? ' selected' : '') + '>13% ED or higher</option>';
                html += '<option value="14+"' + (edFilter === '14+' ? ' selected' : '') + '>14% ED or higher</option>';
                html += '<option value="15"' + (edFilter === '15' ? ' selected' : '') + '>15% ED only</option>';
                html += '</select>';
                html += '</div>';
                html += '</div>';
            }

            // ILVL Setting (for magic crafting bases and rare items)
            if (category === 'magicCrafting' || category === 'rareJewelry' || category === 'rareClassItems' || category === 'rareEliteBases') {
                const item = findItemByKey(category, itemKey);
                if (item) {
                    html += '<div class="modal-section">';
                    html += '<h4 class="modal-section-title">Item Level Requirement</h4>';
                    html += '<div class="modal-control-group">';
                    html += '<label style="display: block; margin-bottom: 8px;">Minimum ILVL:</label>';
                    const currentIlvl = item.minIlvl || 1;
                    html += '<input type="number" id="item-ilvl-' + itemKey + '" min="1" max="99" value="' + currentIlvl + '" ';
                    html += 'style="width: 80px; padding: 6px; border: 1px solid #555; background: #1a1a1a; color: #fff; border-radius: 4px;" ';
                    html += 'onchange="updateModalIlvl(\'' + category + '\', \'' + itemKey + '\', this.value)">';
                    html += '<p style="color: #888; font-size: 12px; margin-top: 8px;">Sets the minimum item level for this item to appear.</p>';
                    html += '</div>';
                    html += '</div>';
                }
            }

            // Custom Colors Section
            html += '<div class="modal-section">';
            html += '<h4 class="modal-section-title">Custom Colors</h4>';
            html += '<div class="modal-control-group">';
            
            // Custom colors toggle
            const customEnabled = state.useCustomColors ? 'checked' : '';
            html += `
                <label class="modal-checkbox-label">
                    <input type="checkbox" ${customEnabled} 
                        onchange="toggleModalCustomColor('${category}', '${itemKey}', this.checked, '${itemType}')">
                    <span>Enable Custom Colors</span>
                </label>
            `;

            if (state.useCustomColors) {
                // Font Color
                html += '<div class="modal-color-row">';
                html += '<span class="modal-color-label">Font Color:</span>';
                html += '<select class="modal-select" onchange="updateModalFontColor(\'' + category + '\', \'' + itemKey + '\', this.value, \'' + itemType + '\')">';
//                html += '<option value="">Default</option>';
                FONT_COLORS.forEach(fc => {
                    const selected = state.fontColor === fc ? 'selected' : '';
                    html += `<option value="${fc}" ${selected}>${fc}</option>`;
                });
                html += '</select>';
                html += '<button class="modal-clear-btn" onclick="clearModalFontColor(\'' + category + '\', \'' + itemKey + '\', \'' + itemType + '\')">Clear</button>';
                html += '</div>';

                // Border Color
                html += '<div class="modal-color-row">';
                html += '<span class="modal-color-label">Border Color:</span>';
                const borderColor = state.borderColor || '#ffffff';
                html += '<input type="color" class="modal-color-input" value="' + borderColor + '" ';
                html += 'onchange="updateModalBorderColor(\'' + category + '\', \'' + itemKey + '\', this.value, \'' + itemType + '\')">';
                html += '<button class="modal-clear-btn" onclick="clearModalBorderColor(\'' + category + '\', \'' + itemKey + '\', \'' + itemType + '\')">Clear</button>';
                html += '</div>';

                // Background Color
                html += '<div class="modal-color-row">';
                html += '<span class="modal-color-label">Background Color:</span>';
                const bgColor = state.backgroundColor || '#000000';
                html += '<input type="color" class="modal-color-input" value="' + bgColor + '" ';
                html += 'onchange="updateModalBackgroundColor(\'' + category + '\', \'' + itemKey + '\', this.value, \'' + itemType + '\')">';
                html += '<button class="modal-clear-btn" onclick="clearModalBackgroundColor(\'' + category + '\', \'' + itemKey + '\', \'' + itemType + '\')">Clear</button>';
                html += '</div>';
            }
            
            html += '</div>';
            html += '</div>';

            // Notify Section
            html += '<div class="modal-section">';
            html += '<h4 class="modal-section-title">Notifications</h4>';
            html += '<div class="modal-control-group">';
            const notifyChecked = state.chatNotification ? 'checked' : '';
            html += `
                <label class="modal-checkbox-label">
                    <input type="checkbox" ${notifyChecked} 
                        onchange="updateModalNotify('${category}', '${itemKey}', this.checked, '${itemType}')">
                    <span>Enable chat notification when this item drops</span>
                </label>
            `;
            html += '</div>';
            html += '</div>';

            // Scroll-specific option: Only show when low
            if (category === 'utility' && (itemKey === 'tsc' || itemKey === 'isc')) {
                html += '<div class="modal-section">';
                html += '<h4 class="modal-section-title">Scroll Display Options</h4>';
                html += '<div class="modal-control-group">';
                const onlyWhenLowEnabled = state.onlyShowWhenLow ? 'checked' : '';
                const scrollType = itemKey === 'tsc' ? 'Town Portal (>15)' : 'Identify (>25)';
                html += `
                    <label class="modal-checkbox-label">
                        <input type="checkbox" ${onlyWhenLowEnabled} 
                            onchange="toggleModalOnlyShowWhenLow('${category}', '${itemKey}', this.checked, '${itemType}')">
                        <span>Only show when running low ${scrollType}</span>
                    </label>
                `;
                html += '</div>';
                html += '</div>';
            }

            // Custom Name Section
            html += '<div class="modal-section">';
            html += '<h4 class="modal-section-title">Custom Name</h4>';
            html += '<div class="modal-control-group">';
            const customNameEnabled = state.useCustomName ? 'checked' : '';
            html += `
                <label class="modal-checkbox-label">
                    <input type="checkbox" ${customNameEnabled} 
                        onchange="toggleModalCustomName('${category}', '${itemKey}', this.checked, '${itemType}')">
                    <span>Use custom name instead of %NAME%</span>
                </label>
            `;
            if (state.useCustomName) {
                // Always use the latest value from state, so after import it is shown
                const customName = (filterState[category] && filterState[category][itemKey] && typeof filterState[category][itemKey].customName === 'string')
                    ? filterState[category][itemKey].customName
                    : '';
                html += '<div style="margin-top: 10px;">';
                html += '<label style="display: block; margin-bottom: 5px; color: #888;">Custom display name:</label>';
                html += `<input type="text" class="modal-text-input" value="${customName}" 
                    onchange="updateModalCustomName('${category}', '${itemKey}', this.value, '${itemType}')"
                    placeholder="e.g., TP for Town Portal" style="width: 100%; padding: 8px; border: 1px solid #444; background: #1a1a1a; color: #fff; border-radius: 4px;">`;
                html += '</div>';
            }
            html += '</div>';
            html += '</div>';

            // Display Options Section
            html += '<div class="modal-section">';
            html += '<h4 class="modal-section-title">Display Options</h4>';
            html += '<div class="modal-control-group">';
            const clickboxChecked = state.biggerClickbox ? 'checked' : '';
            html += `
                <label class="modal-checkbox-label">
                    <input type="checkbox" ${clickboxChecked} 
                        onchange="updateModalBiggerClickbox('${category}', '${itemKey}', this.checked, '${itemType}')">
                    <span>Bigger clickbox (adds spacing around item name)</span>
                </label>
            `;
            html += '</div>';
            html += '</div>';

            return html;
        }

        // Modal update functions
        function updateModalFilterLevel(category, itemKey, levelIndex, checked, itemType) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { show: true, filterLevels: [] };
            if (!filterState[category][itemKey].filterLevels) filterState[category][itemKey].filterLevels = [];
            
            filterState[category][itemKey].filterLevels[levelIndex] = checked;
            generateFilter();

            // Get item code for highlighting
            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function setAllModalLevels(category, itemKey, checked, itemType) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { show: true, filterLevels: [] };
            if (!filterState[category][itemKey].filterLevels) filterState[category][itemKey].filterLevels = [];
            
            for (let i = 0; i < 10; i++) {
                filterState[category][itemKey].filterLevels[i] = checked;
            }
            
            // Refresh modal content
            openItemSettings(category, itemKey, document.getElementById('modalItemName').textContent, itemType);
            generateFilter();

            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function toggleModalCustomColor(category, itemKey, checked, itemType) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { show: true };
            
            filterState[category][itemKey].useCustomColors = checked;
            
            // Refresh modal to show/hide color controls
            openItemSettings(category, itemKey, document.getElementById('modalItemName').textContent, itemType);
            generateFilter();
            updateSettingsButtonState(category, itemKey, itemType);

            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function updateModalFontColor(category, itemKey, color, itemType) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { shown: true };
            
            filterState[category][itemKey].fontColor = color;
            generateFilter();
            updateSettingsButtonState(category, itemKey, itemType);

            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType, category);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function clearModalFontColor(category, itemKey, itemType) {
            updateModalFontColor(category, itemKey, '', itemType);
            openItemSettings(category, itemKey, document.getElementById('modalItemName').textContent, itemType);
        }

        function updateModalBorderColor(category, itemKey, color, itemType) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { shown: true };
            
            filterState[category][itemKey].borderColor = color;
            generateFilter();
            updateSettingsButtonState(category, itemKey, itemType);

            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType, category);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function clearModalBorderColor(category, itemKey, itemType) {
            if (filterState[category]?.[itemKey]) {
                delete filterState[category][itemKey].borderColor;
            }
            openItemSettings(category, itemKey, document.getElementById('modalItemName').textContent, itemType);
            generateFilter();

            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType, category);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function updateModalBackgroundColor(category, itemKey, color, itemType) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { shown: true };
            
            filterState[category][itemKey].backgroundColor = color;
            generateFilter();
            updateSettingsButtonState(category, itemKey, itemType);

            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType, category);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function clearModalBackgroundColor(category, itemKey, itemType) {
            if (filterState[category]?.[itemKey]) {
                delete filterState[category][itemKey].backgroundColor;
            }
            openItemSettings(category, itemKey, document.getElementById('modalItemName').textContent, itemType);
            generateFilter();

            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType, category);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function toggleModalCustomName(category, itemKey, checked, itemType) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { show: true };
            
            filterState[category][itemKey].useCustomName = checked;
            if (!checked) {
                delete filterState[category][itemKey].customName;
            }
            
            openItemSettings(category, itemKey, document.getElementById('modalItemName').textContent, itemType);
            generateFilter();
            updateSettingsButtonState(category, itemKey, itemType);

            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType, category);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function updateModalCustomName(category, itemKey, name, itemType) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { show: true };
            
            filterState[category][itemKey].customName = name;
            generateFilter();
            updateSettingsButtonState(category, itemKey, itemType);

            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType, category);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function toggleModalOnlyShowWhenLow(category, itemKey, checked, itemType) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { show: true };
            
            filterState[category][itemKey].onlyShowWhenLow = checked;
            
            generateFilter();
            updateSettingsButtonState(category, itemKey, itemType);

            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType, category);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function updateModalNotify(category, itemKey, checked, itemType) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { show: true };
            
            filterState[category][itemKey].chatNotification = checked;
            generateFilter();
            updateSettingsButtonState(category, itemKey, itemType);

            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType, category);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function updateModalBiggerClickbox(category, itemKey, checked, itemType) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { show: true };
            
            filterState[category][itemKey].biggerClickbox = checked;
            generateFilter();
            updateSettingsButtonState(category, itemKey, itemType);

            const item = findItemByKey(category, itemKey);
            if (item) {
                const prefix = getItemPrefix(itemType, category);
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        // NMAG-specific modal functions
        function updateModalEthFilter(category, itemKey, value) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { shown: true };
            
            filterState[category][itemKey].ethFilter = value;
            generateFilter();
            updateSettingsButtonState(category, itemKey, 'nmag');

            const item = findItemByKey(category, itemKey);
            if (item) {
                const classSkillCategories = ['nmagAmazonSkills', 'nmagPaladinSkills', 'nmagSorceressSkills', 'nmagDruidSkills', 'nmagBarbarianSkills', 'nmagNecromancerSkills', 'nmagAssassinSkills'];
                const prefix = classSkillCategories.includes(category) ? null : 'NMAG';
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function updateModalSocket(category, itemKey, socketValue, checked) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { show: true, sockFilter: [] };
            if (!filterState[category][itemKey].sockFilter) filterState[category][itemKey].sockFilter = [];
            
            if (checked) {
                // Add socket value if not already present
                if (!filterState[category][itemKey].sockFilter.includes(socketValue)) {
                    filterState[category][itemKey].sockFilter.push(socketValue);
                }
            } else {
                // Remove socket value
                const index = filterState[category][itemKey].sockFilter.indexOf(socketValue);
                if (index > -1) {
                    filterState[category][itemKey].sockFilter.splice(index, 1);
                }
            }
            
            generateFilter();
            updateSettingsButtonState(category, itemKey, 'nmag');

            const item = findItemByKey(category, itemKey);
            if (item) {
                const classSkillCategories = ['nmagAmazonSkills', 'nmagPaladinSkills', 'nmagSorceressSkills', 'nmagDruidSkills', 'nmagBarbarianSkills', 'nmagNecromancerSkills', 'nmagAssassinSkills'];
                const prefix = classSkillCategories.includes(category) ? null : 'NMAG';
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function updateModalEDFilter(category, itemKey, value) {
            if (!filterState[category]) filterState[category] = {};
            if (!filterState[category][itemKey]) filterState[category][itemKey] = { shown: true };
            
            filterState[category][itemKey].edFilter = value;
            generateFilter();
            updateSettingsButtonState(category, itemKey, 'nmag');

            const item = findItemByKey(category, itemKey);
            if (item) {
                const classSkillCategories = ['nmagAmazonSkills', 'nmagPaladinSkills', 'nmagSorceressSkills', 'nmagDruidSkills', 'nmagBarbarianSkills', 'nmagNecromancerSkills', 'nmagAssassinSkills'];
                const prefix = classSkillCategories.includes(category) ? null : 'NMAG';
                setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
            }
        }

        function updateModalIlvl(category, itemKey, value) {
            const item = findItemByKey(category, itemKey);
            if (!item) return;
            
            const ilvl = parseInt(value) || 1;
            item.minIlvl = ilvl;
            
            // Update item name to reflect new ILVL (if it has ILVL in the name)
            if (item.name.includes('ILVL')) {
                const baseName = item.name.replace(/\(ILVL \d+\+?\)/, '').replace(/\(ILVL \d+-\d+\)/, '').trim();
                item.name = `${baseName} (ILVL ${ilvl}+)`;
            }
            
            generateFilter();
            
            // Get the correct prefix for this item type
            let itemType = 'nmag'; // default
            if (category === 'unique') itemType = 'unique';
            else if (category === 'set') itemType = 'set';
            else if (category === 'magicJewelry' || category === 'magicCharms' || category === 'magicCrafting') itemType = 'magic';
            else if (category === 'rareJewelry' || category === 'rareClassItems' || category === 'rareEliteBases') itemType = 'rare';
            
            updateSettingsButtonState(category, itemKey, itemType);

            const prefix = getItemPrefix(itemType, category);
            setTimeout(() => highlightItemInOutput(item.code, prefix), 100);
        }

        // Helper functions
        function findItemByKey(category, itemKey) {
            // For simple categories (utility, runes, gems, misc), itemKey is the code
            const simpleCategoriesMap = {
                'utility': utilityItems,
                'runes': runeItems,
                'gems': gemItems,
                'misc': miscItems
            };
            
            if (simpleCategoriesMap[category]) {
                return simpleCategoriesMap[category].find(item => item.code === itemKey);
            }
            
            // For magic/rare item categories
            const magicRareCategoriesMap = {
                'magicJewelry': magicJewelry,
                'magicCharms': magicCharms,
                'magicCrafting': magicCraftingBases,
                'rareJewelry': rareJewelry,
                'rareClassItems': rareClassItems,
                'rareEliteBases': rareEliteBases
            };
            
            if (magicRareCategoriesMap[category]) {
                // For magic/rare items, the key is code_index, so extract the code
                const code = (typeof itemKey === 'string' && itemKey.includes('_')) ? itemKey.split('_')[0] : itemKey;
                return magicRareCategoriesMap[category].find(item => item.code === code);
            }
            
            // For complex categories, look up by sanitized name or code
            const items = window[category];
            if (!items) return null;
            return items.find(item => {
                const sanitized = item.name.replace(/[\s']/g, '_');
                return sanitized === itemKey || item.code === itemKey;
            });
        }

        function getItemPrefix(itemType, category = null) {
            // Check if this is a class skill item (these don't use prefixes in ItemDisplay)
            const classSkillCategories = ['nmagAmazonSkills', 'nmagPaladinSkills', 'nmagSorceressSkills', 'nmagDruidSkills', 'nmagBarbarianSkills', 'nmagNecromancerSkills', 'nmagAssassinSkills'];
            if (category && classSkillCategories.includes(category)) {
                return null;
            }
            
            const prefixMap = {
                'unique': 'UNI',
                'set': 'SET',
                'magic': 'MAG',
                'rare': 'RARE',
                'nmag': 'NMAG'
            };
            return prefixMap[itemType] || null;
        }

        // Export filter
        function exportFilter() {
            let output = document.getElementById('filter-output').value;

            // Remove any existing //COMMUNITY_MODULES section to avoid duplicates
            output = output.replace(/\n?\/\/COMMUNITY_MODULES:({[\s\S]*?})\n?/g, '');

            // Always append the COMMUNITY_MODULES section at the end
            let communityModulesSection = '';
            if (filterState.communityModules && Object.keys(filterState.communityModules).length > 0) {
                communityModulesSection = '\n//COMMUNITY_MODULES:' + JSON.stringify(filterState.communityModules) + '\n';
            } else {
                // Still add the section for consistency, even if empty
                communityModulesSection = '\n//COMMUNITY_MODULES:{}\n';
            }

            // Ensure custom filter lines (// === CUSTOM ...) remain above the utility section
            // Find the utility section
            const utilitySectionRegex = /^(.*?)(^\/\/ === UTILITY.*)$/ms;
            const match = output.match(utilitySectionRegex);
            if (match) {
                // Insert the community modules section at the very end, after everything
                output = match[1] + match[2];
            }
            // Append the community modules section at the end (after all content)
            output = output.replace(/\n?\/\/COMMUNITY_MODULES:({[\s\S]*?})\n?/g, ''); // Remove any stray ones again
            output = output.replace(/\n+$/, ''); // Remove trailing newlines
            output += communityModulesSection;

            const blob = new Blob([output], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // Check if surprise me is enabled
            const surpriseMe = document.getElementById('surprise-me')?.checked || false;
            let filename = 'FPCustom';
            if (surpriseMe) {
                filename = addRandomColors(filename);
            }
            a.download = filename + '.filter';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function toggleSurpriseMe(enabled) {
            // Regenerate filter to update filter level names with/without colors
            generateFilter();
        }
        
        // Copy to clipboard
        function copyToClipboard() {
            const output = document.getElementById('filter-output');
            output.select();
            document.execCommand('copy');
            alert('Filter copied to clipboard!');
        }

        // Import filter
        function importLegacyFilter(event) {
            console.log('[IMPORT] importFilter called');
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                // DEBUG: Custom section regex test - BEGIN
                console.log('[IMPORT] DEBUG: Custom section regex test - BEGIN');
                try {
                    // Updated regex: require a newline after the header, then capture everything up to the next section header or end of file
                    const customSectionRegex = /^\s*\/\/ === CUSTOM \(COMMUNITY MODULES\) ===\s*\n([\s\S]*?)(?=^\s*\/\/ ===|$)/m;
                    let customSectionMatch = content.match(customSectionRegex);
                    if (!customSectionMatch) {
                        // Fallback: match header and everything after, even if on the same line (legacy)
                        const fallbackRegex = /\/\/ === CUSTOM \(COMMUNITY MODULES\) ===([\s\S]*?)(?=^\s*\/\/ ===|$)/m;
                        const fallbackMatch = content.match(fallbackRegex);
                        if (fallbackMatch) {
                            customSectionMatch = fallbackMatch;
                            console.log('[IMPORT] Fallback customSectionMatch: MATCHED', fallbackMatch);
                        }
                    }
                    console.log('[IMPORT] customSectionRegex (final):', customSectionRegex);
                    console.log('[IMPORT] First 1000 chars of content:', content.slice(0, 1000));
                    if (customSectionMatch) {
                        console.log('[IMPORT] customSectionMatch: MATCHED', customSectionMatch);
                    } else {
                        console.log('[IMPORT] customSectionMatch: NOT MATCHED');
                        const idx = content.indexOf('// === CUSTOM (COMMUNITY MODULES) ===');
                        if (idx !== -1) {
                            console.log('[IMPORT] Content after CUSTOM header (500 chars):', content.slice(idx, idx + 500));
                        } else {
                            console.log('[IMPORT] CUSTOM header not found in content.');
                        }
                    }
                } catch (e) {
                    console.error('[IMPORT] Exception during custom section regex debug:', e);
                }
                console.log('[IMPORT] DEBUG: Custom section regex test - END');

                // WARNING: Setting filter-output.value here will be immediately overwritten by generateFilter()
                // if it is called after import. Any custom or trailing lines (such as //COMMUNITY_MODULES)
                // will be lost unless they are handled in the state and generation logic.
                document.getElementById('filter-output').value = content;

                // Wait for window.communityModules to be loaded before restoring state and UI
                const waitForModules = (cb) => {
                    console.log('[IMPORT] waitForModules check:', window.communityModules);
                    if (window.communityModules && Object.keys(window.communityModules).length > 0) {
                        console.log('[IMPORT] waitForModules: modules loaded, running callback');
                        cb();
                    } else {
                        setTimeout(() => waitForModules(cb), 50);
                    }
                };
                waitForModules(() => {
                    try {
                        // --- BEGIN LOGGING AND PARSING ---
                        console.log('[IMPORT] --- Begin Import ---');
                        console.log('[IMPORT] First 500 chars of content:', content.slice(0, 500));
                        // Extract communityModules state from special comment section if present
                        let cmMatch = content.match(/\/\/COMMUNITY_MODULES:({[\s\S]*?})/);
                        let parsedCommunityModules = false;
                        if (cmMatch) {
                            try {
                                const cmObj = JSON.parse(cmMatch[1]);
                                filterState.communityModules = cmObj;
                                parsedCommunityModules = true;
                                console.log('[IMPORT] Parsed COMMUNITY_MODULES section:', cmObj);
                            } catch (e) {
                                console.warn('Failed to parse COMMUNITY_MODULES:', e);
                            }
                        }
                        // Always attempt to extract and process the custom section, regardless of above
                        // Updated regex: capture everything after the header up to the next section header or end of file, including blank lines
                        const customSectionRegex = /^\s*\/\/ === CUSTOM \(COMMUNITY MODULES\) ===[ \t]*\n([\s\S]*?)(?=^\s*\/\/ ===|\Z)/m;
                        const customSectionMatch = content.match(customSectionRegex);
                        console.log('[IMPORT] customSectionRegex (final):', customSectionRegex);
                        console.log('[IMPORT] First 1000 chars of content:', content.slice(0, 1000));
                        if (customSectionMatch && window.communityModules) {
                            console.log('[IMPORT] customSectionMatch: MATCHED', customSectionMatch);
                            console.log('[IMPORT] customSectionMatch[1] (raw section):', customSectionMatch[1]);
                            const rawSection = customSectionMatch[1];
                            const splitLines = rawSection.split('\n');
                            console.log('[IMPORT] splitLines:', splitLines);
                            let lines = splitLines.map(l => l.trim()).filter(l => l.startsWith('ItemDisplay['));
                            console.log('[IMPORT] Filtered ItemDisplay lines:', lines);
                            if (lines.length === 0) {
                                console.log('[IMPORT] No ItemDisplay lines found in custom section!');
                            }
                            // Parse ItemDisplay lines into {lhs, rhs, raw}
                            const parseItemDisplay = s => {
                                const m = s.match(/^(ItemDisplay\[[^\]]+\]):?(.*)$/);
                                return m ? { lhs: m[1].trim(), rhs: m[2].trim(), raw: s } : { lhs: '', rhs: '', raw: s };
                            };
                            const parsedLines = lines.map(parseItemDisplay);
                            // Normalize lines for robust comparison, ignore trailing colons and whitespace
                            const normalize = s => s.replace(/\s+/g, ' ').replace(/\r/g, '').replace(/:$/, '').trim();
                            const normLines = parsedLines.map(pl => normalize(pl.lhs + (pl.rhs ? ':' + pl.rhs : '')));
                            console.log('[IMPORT] Normalized lines:', normLines);
                            parsedLines.forEach((pl, idx) => {
                                console.log(`[IMPORT] parsedLines[${idx}]: lhs='${pl.lhs}', rhs='${pl.rhs}', raw='${pl.raw}'`);
                            });
                            if (!filterState.communityModules) filterState.communityModules = {};
                            Object.entries(window.communityModules).forEach(([moduleName, rules]) => {
                                console.log(`[IMPORT] Module: ${moduleName}, rules array:`, rules);
                                rules.forEach(rule => {
                                    console.log(`[IMPORT] Module: ${moduleName}, full rule object:`, rule);
                                    if (Array.isArray(rule.filterLines) && rule.filterLines.length > 0) {
                                        rule.filterLines.forEach((fl, ridx) => {
                                            const trimmed = normalize(fl);
                                            console.log(`[IMPORT] rule.filterLines[${ridx}]: '${trimmed}' char codes:`, Array.from(trimmed).map(c => c.charCodeAt(0)));
                                        });
                                        let matched = false;
                                        let customName = null;
                                        for (const fl of rule.filterLines) {
                                            const trimmed = normalize(fl);
                                            // 1. Exact match
                                            let matchIdx = normLines.findIndex(line => line === trimmed);
                                            // 2. Fallback: match if normLines contains just the left-hand side (up to colon)
                                            if (matchIdx === -1) {
                                                const lhs = trimmed.split(':')[0];
                                                matchIdx = parsedLines.findIndex(pl => normalize(pl.lhs) === lhs);
                                                if (matchIdx !== -1) {
                                                    console.log(`[IMPORT] Fallback match: found LHS '${lhs}' in parsedLines for rule '${trimmed}'`);
                                                }
                                            }
                                            // 3. Fallback: match if any normLine is a prefix of the rule's filterLine
                                            if (matchIdx === -1) {
                                                matchIdx = normLines.findIndex(line => trimmed.startsWith(line));
                                                if (matchIdx !== -1) {
                                                    console.log(`[IMPORT] Prefix match: normLine is prefix of rule.filterLine '${trimmed}'`);
                                                }
                                            }
                                            if (matchIdx !== -1) {
                                                if (!filterState.communityModules[moduleName]) filterState.communityModules[moduleName] = {};
                                                filterState.communityModules[moduleName][rule.id] = true;
                                                // Extract and store custom name/text if present
                                                const pl = parsedLines[matchIdx];
                                                if (pl && pl.rhs && pl.rhs !== '%NAME%') {
                                                    if (!filterState.communityModulesCustomNames) filterState.communityModulesCustomNames = {};
                                                    if (!filterState.communityModulesCustomNames[moduleName]) filterState.communityModulesCustomNames[moduleName] = {};
                                                    filterState.communityModulesCustomNames[moduleName][rule.id] = pl.rhs;
                                                    console.log(`[IMPORT] Stored custom name for ${moduleName} / ${rule.id}: '${pl.rhs}'`);
                                                }
                                                console.log(`[IMPORT] Matched rule: ${moduleName} / ${rule.id} by filterLine: '${trimmed}'`);
                                                matched = true;
                                                break;
                                            }
                                        }
                                        if (!matched) {
                                            console.log(`[IMPORT] No match for rule: ${moduleName} / ${rule.id}`);
                                        }
                                    } else {
                                        console.log(`[IMPORT] Rule ${rule.id} in module ${moduleName} has no filterLines or filterLines is not an array.`);
                                    }
                                });
                            });
                            console.log('[IMPORT] filterState.communityModules after matching:', JSON.stringify(filterState.communityModules));
                            if (filterState.communityModulesCustomNames) {
                                console.log('[IMPORT] filterState.communityModulesCustomNames:', JSON.stringify(filterState.communityModulesCustomNames));
                            }
                        } else {
                            if (!customSectionMatch) {
                                console.log('[IMPORT] CUSTOM (COMMUNITY MODULES) section regex did not match.');
                            }
                            if (!window.communityModules) {
                                console.log('[IMPORT] window.communityModules is not loaded.');
                            }
                        }
                        // Always initialize to empty object if still undefined
                        if (!filterState.communityModules) filterState.communityModules = {};
                        // Log the final state before UI rebuild
                        console.log('[IMPORT] Final filterState.communityModules:', JSON.stringify(filterState.communityModules));
                        console.log('[IMPORT] window.communityModules keys:', Object.keys(window.communityModules));
                        Object.entries(window.communityModules).forEach(([moduleName, rules]) => {
                            console.log(`[IMPORT] Module: ${moduleName}, Rule IDs:`, rules.map(r => r.id));
                        });
                        // --- END LOGGING AND PARSING ---
                        if (typeof loadCommunityModulesUI === 'function') loadCommunityModulesUI(); // Force UI update for checkboxes
                        parseFilterAndUpdateState(content);
                        if (typeof generateFilter === 'function') setTimeout(generateFilter, 0);
                        alert('Filter imported successfully! All settings have been loaded.');
                        updateOutputStats();
                    } catch (error) {
                        console.error('Import error:', error);
                        alert('Filter imported but could not fully parse: ' + error.message);
                        updateOutputStats();
                    }
                });
            };
            reader.readAsText(file);
        }

        // Helper: parse a section and update only the relevant filter state
        function parseSectionAndUpdateState(sectionName, sectionContent) {
            // Map section names to state categories and parsing logic
            const sectionMap = {
                'UNIQUE ITEMS': () => parseFilterAndUpdateState(sectionContent),
                'SET ITEMS': () => parseFilterAndUpdateState(sectionContent),
                'MAGIC ITEMS': () => parseFilterAndUpdateState(sectionContent),
                'RARE ITEMS': () => parseFilterAndUpdateState(sectionContent),
                'UTILITY': () => parseFilterAndUpdateState(sectionContent),
                'RUNES': () => parseFilterAndUpdateState(sectionContent),
                'GEMS': () => parseFilterAndUpdateState(sectionContent),
                'MISC': () => parseFilterAndUpdateState(sectionContent),
                'NMAG RUNEWORD BASES': () => parseFilterAndUpdateState(sectionContent),
                // Add more mappings as needed
            };
            if (sectionMap[sectionName]) {
                sectionMap[sectionName]();
            } else {
                // Default: try to parse as generic ItemDisplay lines
                parseFilterAndUpdateState(sectionContent);
            }
        }

        function parseFilterAndUpdateState(filterContent) {
            const lines = filterContent.split('\n');
            
            // Parse FilterLevel declarations
            const filterLevelRegex = /FilterLevel\[(\d+)\]:\s*(.+)/;
            lines.forEach(line => {
                const match = line.match(filterLevelRegex);
                if (match) {
                    const level = parseInt(match[1]) - 1;
                    const name = match[2].trim();
                    if (level >= 0 && level < 10) {
                        globalSettings.levelNames[level] = name;
                        globalSettings.enableFilterLevels = true;
                    }
                }
            });
            
            // Parse ItemDisplay lines
            const itemDisplayRegex = /ItemDisplay\[([^\]]+)\]:\s*(.*)$/;
            
            lines.forEach(line => {
                line = line.trim();
                if (!line.startsWith('ItemDisplay[')) return;
                
                const match = line.match(itemDisplayRegex);
                if (!match) return;
                
                const condition = match[1];
                const display = match[2];
                
                // Parse the condition and display parts
                parseItemDisplayLine(condition, display);
            });
            
            // Update UI
            if (globalSettings.enableFilterLevels) {
                document.getElementById('enable-filter-levels').checked = true;
                document.getElementById('filter-levels-config').classList.add('active');
                renderLevelNamesConfig();
            }
            
            document.getElementById('hide-junk').checked = globalSettings.hideJunk;
            document.getElementById('show-all').checked = globalSettings.showAll;
            
            // Re-render all sections
            renderAllSections();
        }

        function parseItemDisplayLine(condition, display) {
            const hidden = !display || display.trim() === '';
            
            // Extract codes and conditions
            const parts = condition.split(/\s+/);
            let code = null;
            let rarity = null;
            let isSet = false;
            let isUnique = false;
            let isNmag = false;
            let ethFilter = 'both';
            let sockFilter = [];
            let edFilter = 'any';
            let filterLevels = null;
            
            // Parse condition parts
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                
                if (part === 'UNI') {
                    isUnique = true;
                } else if (part === 'SET') {
                    isSet = true;
                } else if (part === 'NMAG') {
                    isNmag = true;
                } else if (part === 'MAG' || part === 'RARE') {
                    rarity = part;
                } else if (part === 'ETH') {
                    ethFilter = 'eth-only';
                } else if (part === '!ETH') {
                    ethFilter = 'non-eth';
                } else if (part.match(/^SOCK=/)) {
                    // Single socket: SOCK=3
                    const val = part.split('=')[1];
                    if (val) sockFilter.push(val);
                } else if (part === '(SOCK=') {
                    // Multiple sockets: (SOCK=3 OR SOCK=4)
                    // Continue parsing until we hit )
                    for (let j = i + 1; j < parts.length; j++) {
                        if (parts[j].includes('SOCK=')) {
                            const val = parts[j].replace(/[()]/g, '').split('=')[1];
                            if (val) sockFilter.push(val);
                        }
                        if (parts[j].includes(')')) {
                            i = j;
                            break;
                        }
                    }
                } else if (part === 'ED=15') {
                    edFilter = '15';
                } else if (part === 'ED>13') {
                    edFilter = '14+';
                } else if (part === 'ED>12') {
                    edFilter = '13+';
                } else if (part === 'ED>11') {
                    edFilter = '12+';
                } else if (part === 'ED>9') {
                    edFilter = '10+';
                } else if (part.startsWith('FILTLVL')) {
                    // Parse filter level condition
                    filterLevels = parseFilterLevelCondition(part);
                } else if (!part.startsWith('!') && !part.includes('>') && !part.includes('<') && !part.includes('=') && !part.includes('(') && !part.includes(')') && part !== 'OR') {
                    // This is likely the item code
                    code = part;
                }
            }
            
            if (!code) return;
            
            // Parse display formatting
            let fontColor = null;  // Don't initialize to a default - only set if found in display
            let useCustomColors = false;
            let borderColor = null;
            let backgroundColor = null;
            let chatNotification = false;
            let biggerClickbox = false;
            let customName = '';
            let useCustomName = false;
            
            if (display) {
                // Parse color codes (but don't set useCustomColors yet - will determine later if color differs from default)
                // Exclude special keywords like NAME, ILVL, SOCKETS, NL, etc. from being treated as colors
                const colorMatch = display.match(/%([A-Z_]+)%/);
                if (colorMatch) {
                    const potentialColor = colorMatch[1];
                    // Only treat it as a color if it's not a special keyword
                    const specialKeywords = ['NAME', 'ILVL', 'SOCKETS', 'NL', 'CONTINUE', 'MAP-'];
                    if (!specialKeywords.includes(potentialColor) && !potentialColor.startsWith('MAP-')) {
                        fontColor = potentialColor;
                    }
                }
                
                // Check for bigger clickbox
                if (display.includes('%NL%')) {
                    biggerClickbox = true;
                }
                
                // Custom name extraction for regular items
                // If display is not "%NAME%" and not empty, treat as custom name
                if (!display.includes('%NAME%') && !hidden) {
                    useCustomName = true;
                    customName = display.trim();
                } else {
                    useCustomName = false;
                    customName = '';
                }
                
                // Parse CustomDisplay - only this should trigger useCustomColors automatically
                const customMatch = display.match(/<:CustomDisplay:\s*([^>]+)>/);
                if (customMatch) {
                    const customParts = customMatch[1].split(',');
                    customParts.forEach(part => {
                        part = part.trim();
                        if (part.startsWith('NotificationColor')) {
                            chatNotification = true;
                        } else if (part.startsWith('BorderColor')) {
                            const rgbMatch = part.match(/RGB\(([^)]+)\)/);
                            if (rgbMatch) {
                                borderColor = rgbSlashToHex(rgbMatch[1]);
                                useCustomColors = true;
                            }
                        } else if (part.startsWith('BackgroundColor')) {
                            const rgbMatch = part.match(/RGB\(([^)]+)\)/);
                            if (rgbMatch) {
                                backgroundColor = rgbSlashToHex(rgbMatch[1]);
                                useCustomColors = true;
                            }
                        }
                    });
                }
            }
            
            // Prepare state object - only include properties that were found
            const baseState = {
                show: !hidden,
                borderColor,
                backgroundColor,
                chatNotification,
                biggerClickbox,
                customName,
                useCustomName
            };
            
            // Only include fontColor if we actually found one in the display
            if (fontColor !== null) {
                baseState.fontColor = fontColor;
            }
            
            // Only add useCustomColors if we detected borders/backgrounds
            // The update functions will set it based on whether fontColor differs from default
            if (useCustomColors) {
                baseState.useCustomColors = true;
            }
            
            if (filterLevels) {
                baseState.filterLevels = filterLevels;
            }
            
            // Update filterState based on item type
            if (isNmag) {
                updateNmagItemState(code, {
                    ...baseState,
                    ethFilter,
                    sockFilter,
                    edFilter
                });
            } else if (isUnique) {
                // Find the correct category for this unique item code
                let uniqueCategory = null;
                if (eliteWeapons && eliteWeapons.find(i => i.code === code)) uniqueCategory = 'eliteWeapons';
                else if (eliteArmor && eliteArmor.find(i => i.code === code)) uniqueCategory = 'eliteArmor';
                else if (excWeapons && excWeapons.find(i => i.code === code)) uniqueCategory = 'excWeapons';
                else if (excArmor && excArmor.find(i => i.code === code)) uniqueCategory = 'excArmor';
                else if (normWeapons && normWeapons.find(i => i.code === code)) uniqueCategory = 'normWeapons';
                else if (normArmor && normArmor.find(i => i.code === code)) uniqueCategory = 'normArmor';
                else if (classSpecificUniques && classSpecificUniques.find(i => i.code === code)) uniqueCategory = 'classUniques';
                else if (jewelryAndCharms && jewelryAndCharms.find(i => i.code === code)) uniqueCategory = 'jewelryCharms';
                if (uniqueCategory) {
                    if (!filterState[uniqueCategory]) filterState[uniqueCategory] = {};
                    filterState[uniqueCategory][code] = { ...baseState };
                }
            } else if (isSet) {
                updateSetItemState(code, baseState);
            } else if (rarity) {
                updateRareMagicItemState(code, rarity, baseState);
            } else {
                // Simple items (utility, runes, gems, misc)
                updateSimpleItemState(code, baseState);
            }
        }

        function parseFilterLevelCondition(filtlvlPart) {
            // Parse FILTLVL>=1<=5 type conditions
            const levels = [false, false, false, false, false, false, false, false, false, false];
            
            // Simple case: FILTLVL=1
            const simpleMatch = filtlvlPart.match(/FILTLVL=(\d+)/);
            if (simpleMatch) {
                const level = parseInt(simpleMatch[1]) - 1;
                if (level >= 0 && level < 10) levels[level] = true;
                return levels;
            }
            
            // Range case: FILTLVL>=1<=5
            const rangeMatch = filtlvlPart.match(/FILTLVL>=(\d+)<=(\d+)/);
            if (rangeMatch) {
                const start = parseInt(rangeMatch[1]) - 1;
                const end = parseInt(rangeMatch[2]) - 1;
                for (let i = start; i <= end && i < 10; i++) {
                    if (i >= 0) levels[i] = true;
                }
                return levels;
            }
            
            return levels;
        }

        function updateSimpleItemState(code, state) {
            // Determine default color and check if current state uses custom colors
            let defaultColor = 'WHITE';
            let stateKey = null;
            let stateCategory = null;
            
            // Check utility items
            const utilItem = utilityItems.find(i => i.code === code);
            if (utilItem) {
                if (!filterState.utility) filterState.utility = {};
                if (!filterState.utility[code]) filterState.utility[code] = {};
                defaultColor = 'WHITE';
                stateKey = code;
                stateCategory = 'utility';
            }

            // Check runes
            const runeItem = runeItems.find(i => i.code === code);
            if (runeItem) {
                if (!filterState.runes) filterState.runes = {};
                if (!filterState.runes[code]) filterState.runes[code] = {};
                defaultColor = 'ORANGE';
                stateKey = code;
                stateCategory = 'runes';
            }

            // Check gems
            const gemItem = gemItems.find(i => i.code === code);
            if (gemItem) {
                if (!filterState.gems) filterState.gems = {};
                if (!filterState.gems[code]) filterState.gems[code] = {};
                defaultColor = 'WHITE';
                stateKey = code;
                stateCategory = 'gems';
            }

            // Check misc
            const miscItem = miscItems.find(i => i.code === code);
            if (miscItem) {
                if (!filterState.misc) filterState.misc = {};
                if (!filterState.misc[code]) filterState.misc[code] = {};
                defaultColor = 'PURPLE';
                stateKey = code;
                stateCategory = 'misc';
            }

            if (stateKey && stateCategory) {
                // Only set useCustomColors if fontColor differs from default OR has borders/backgrounds
                const actualUseCustomColors = 
                    (state.fontColor && state.fontColor !== defaultColor) ||
                    state.borderColor !== null ||
                    state.backgroundColor !== null;

                Object.assign(filterState[stateCategory][stateKey], {
                    ...state,
                    useCustomColors: actualUseCustomColors
                });
            }
        }

        function rgbSlashToHex(rgbStr) {
            // Convert "255/128/0" to "#ff8000"
            const parts = rgbStr.split('/').map(p => parseInt(p.trim()));
            if (parts.length !== 3) return '#ffffff';
            const hex = parts.map(p => {
                const h = Math.max(0, Math.min(255, p)).toString(16);
                return h.length === 1 ? '0' + h : h;
            }).join('');
            return '#' + hex;
        }

        function renderAllSections() {
            renderUtilityItems();
            renderRuneItems();
            renderGemsItems();
            renderMiscItems();
            renderJewelryCharmsItems();
            renderClassUniquesItems();
            renderEliteWeaponsItems();
            renderEliteArmorItems();
            renderExcWeaponsItems();
            renderExcArmorItems();
            renderNormWeaponsItems();
            renderNormArmorItems();
            renderHighSetsItems();
            renderMidSetsItems();
            renderLowSetsItems();
            renderMagicJewelryItems();
            renderMagicCharmsItems();
            renderMagicCraftingItems();
            renderRareJewelryItems();
            renderRareClassItemsItems();
            renderRareEliteBasesItems();
            renderNmagPolearmsItems();
            renderNmagSwordsItems();
            renderNmagAxesItems();
            renderNmagMacesItems();
            renderNmagSpearsItems();
            renderNmagBowsItems();
            renderNmagArmorItems();
            rendernmagShieldsItems();
            renderNmagHelmsItems();
            renderNmagDruidPeltsItems();
            renderNmagNecroHeadsItems();
            renderNmagAssassinClawsItems();
            renderNmagSorcOrbsItems();
            renderNmagDaggersItems();
            renderNmagBarbarianHelmsItems();
//            renderNmagJavelinsItems();
            renderNmagAmazonWeaponsItems();
            generateFilter();
        }

        // Allow manual edits to update stats
        document.getElementById('filter-output').addEventListener('input', updateOutputStats);

        // Toggle filter levels feature
        function toggleFilterLevels(enabled) {
            globalSettings.enableFilterLevels = enabled;
            const configSection = document.getElementById('filter-levels-config');
            
            if (enabled) {
                configSection.classList.add('active');
                renderLevelNamesConfig();
            } else {
                configSection.classList.remove('active');
            }
            
            // Re-render all sections to update UI
            renderUtilityItems();
            renderRuneItems();
            renderGemsItems();
            renderMiscItems();
            renderJewelryCharmsItems();
            renderClassUniquesItems();
            renderEliteWeaponsItems();
            renderEliteArmorItems();
            renderExcWeaponsItems();
            renderExcArmorItems();
            renderNormWeaponsItems();
            renderNormArmorItems();
            renderHighSetsItems();
            renderMidSetsItems();
            renderLowSetsItems();
            renderMagicJewelryItems();
            renderMagicCharmsItems();
            renderMagicCraftingItems();
            renderRareJewelryItems();
            renderRareClassItemsItems();
            renderRareEliteBasesItems();
            renderNmagPolearmsItems();
            renderNmagSwordsItems();
            renderNmagAxesItems();
            renderNmagMacesItems();
            renderNmagSpearsItems();
            renderNmagBowsItems();
            renderNmagArmorItems();
            rendernmagShieldsItems();
            renderNmagHelmsItems();
            renderNmagDruidPeltsItems();
            renderNmagNecroHeadsItems();
            renderNmagAssassinClawsItems();
            renderNmagSorcOrbsItems();
            renderNmagDaggersItems();
            renderNmagBarbarianHelmsItems();
//            renderNmagJavelinsItems();
            renderNmagAmazonWeaponsItems();
            generateFilter();
        }

        // Toggle Hide Junk setting
        function toggleHideJunk(enabled) {
            globalSettings.hideJunk = enabled;
            generateFilter();
        }

        // Toggle Show All setting
        function toggleShowAll(enabled) {
            globalSettings.showAll = enabled;
            generateFilter();
        }

        // Render level names configuration inputs
        function renderLevelNamesConfig() {
            const container = document.getElementById('level-names-grid');
            container.innerHTML = '';
            
            for (let i = 0; i < 10; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'level-name-input';
                wrapper.innerHTML = `
                    <label>Level ${i + 1}</label>
                    <input type="text" 
                        value="${globalSettings.levelNames[i]}" 
                        onchange="updateLevelName(${i}, this.value)"
                        placeholder="Level ${i + 1}">
                `;
                container.appendChild(wrapper);
            }
        }

        // Update level name
        function updateLevelName(level, name) {
            globalSettings.levelNames[level] = name.trim();
            // Re-render all sections to update checkboxes visibility
            renderUtilityItems();
            renderRuneItems();
            renderGemsItems();
            renderMiscItems();
            renderJewelryCharmsItems();
            renderClassUniquesItems();
            renderEliteWeaponsItems();
            renderEliteArmorItems();
            renderExcWeaponsItems();
            renderExcArmorItems();
            renderNormWeaponsItems();
            renderNormArmorItems();
            renderHighSetsItems();
            renderMidSetsItems();
            renderLowSetsItems();
            renderMagicJewelryItems();
            renderMagicCharmsItems();
            renderMagicCraftingItems();
            renderRareJewelryItems();
            renderRareClassItemsItems();
            renderRareEliteBasesItems();
            renderNmagPolearmsItems();
            renderNmagSwordsItems();
            renderNmagAxesItems();
            renderNmagMacesItems();
            renderNmagSpearsItems();
            renderNmagBowsItems();
            renderNmagArmorItems();
            rendernmagShieldsItems();
            renderNmagHelmsItems();
            renderNmagDruidPeltsItems();
            renderNmagNecroHeadsItems();
            renderNmagAssassinClawsItems();
            renderNmagSorcOrbsItems();
            renderNmagDaggersItems();
            renderNmagBarbarianHelmsItems();
//            renderNmagJavelinsItems();
            renderNmagAmazonWeaponsItems();
            generateFilter();
        }

        // Update item filter level
        function updateItemLevel(category, code, level, checked) {
            filterState[category][code].filterLevels[level] = checked;
            generateFilter();
            setTimeout(() => highlightItemInOutput(code), 100);
        }

        // Set all levels for an item
        function setAllLevels(category, code, checked) {
            for (let i = 0; i < 10; i++) {
                filterState[category][code].filterLevels[i] = checked;
            }
            // Re-render the appropriate section to update checkboxes
            if (category === 'jewelryCharms') {
                renderJewelryCharmsItems();
            } else if (category === 'utility') {
                renderUtilityItems();
            } else if (category === 'runes') {
                renderRuneItems();
            } else if (category === 'gems') {
                renderGemsItems();
            } else if (category === 'misc') {
                renderMiscItems();
            } else if (category === 'classUniques') {
                renderClassUniquesItems();
            } else if (category === 'eliteWeapons') {
                renderEliteWeaponsItems();
            } else if (category === 'eliteArmor') {
                renderEliteArmorItems();
            } else if (category === 'excWeapons') {
                renderExcWeaponsItems();
            } else if (category === 'excArmor') {
                renderExcArmorItems();
            } else if (category === 'normWeapons') {
                renderNormWeaponsItems();
            } else if (category === 'normArmor') {
                renderNormArmorItems();
            }
            generateFilter();
        }

        // Initialize
        renderUtilityItems();
        renderRuneItems();
        renderGemsItems();
        renderMiscItems();
        renderJewelryCharmsItems();
        renderClassUniquesItems();
        renderEliteWeaponsItems();
        renderEliteArmorItems();
        renderExcWeaponsItems();
        renderExcArmorItems();
        renderNormWeaponsItems();
        renderNormArmorItems();
        renderHighSetsItems();
        renderMidSetsItems();
        renderLowSetsItems();
        renderMagicJewelryItems();
        renderMagicCharmsItems();
        renderMagicCraftingItems();
        renderRareJewelryItems();
        renderRareClassItemsItems();
        renderRareEliteBasesItems();
        renderNmagAmazonSkillsItems();
        renderNmagAssassinSkillsItems();
        renderNmagBarbarianSkillsItems();
        renderNmagDruidSkillsItems();
        renderNmagNecromancerSkillsItems();
        renderNmagPaladinSkillsItems();
        renderNmagSorceressSkillsItems();
        renderNmagPolearmsItems();
        renderNmagSwordsItems();
        renderNmagAxesItems();
        renderNmagMacesItems();
        renderNmagSpearsItems();
        renderNmagBowsItems();
        renderNmagArmorItems();
        rendernmagShieldsItems();
        renderNmagHelmsItems();
        renderNmagDaggersItems();
        generateFilter();
    </script>

    <!-- Item Settings Modal -->
    <div class="modal-overlay" id="itemSettingsModal" onclick="closeItemSettings(event)">
        <div class="modal-container" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3 class="modal-title" id="modalItemName"></h3>
                <button class="modal-close" onclick="closeItemSettings()">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Content will be populated dynamically -->
            </div>
        </div>
    </div>

    <script>
    function toggleImportSource() {
        const source = document.getElementById('import-source').value;
        document.getElementById('local-import').style.display = source === 'local' ? 'block' : 'none';
        document.getElementById('url-import').style.display = source === 'url' ? 'block' : 'none';
    }

        // Robust enhanced import dropdown logic
        document.addEventListener('DOMContentLoaded', function () {
            const menu = document.getElementById('enhanced-import-menu');
            const btn = document.getElementById('enhanced-import-btn');
            if (!menu || !btn) return;

            // Toggle menu on button click
            btn.addEventListener('click', function (e) {
                e.stopPropagation();
                menu.style.display = (menu.style.display === 'block') ? 'none' : 'block';
            });

            // Prevent menu from closing when clicking inside
            menu.addEventListener('click', function (e) {
                e.stopPropagation();
            });

            // Close menu on outside click
            document.addEventListener('click', function () {
                menu.style.display = 'none';
            });

            // Close menu on Escape key
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') {
                    menu.style.display = 'none';
                }
            });
        });


    function processImportedData(data, sections) {
        if (sections.includes('all')) {
            console.log('Importing entire filter:', data);
        } else {
            console.log('Importing selected sections:', sections, data);
        }
        // Further processing logic goes here
    }
    </script>
</body>
</html>
